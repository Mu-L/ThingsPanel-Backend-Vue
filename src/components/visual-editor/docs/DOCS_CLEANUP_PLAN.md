# Visual Editor 组件清理与重构计划

## 1. 目标

本计划旨在根据 `DOCS_ANALYSIS.md` 中的分析结果，对 `visual-editor` 组件进行一次全面的清理和重构。主要目标包括：

- **移除冗余代码**: 删除不再使用或功能重复的文件。
- **优化项目结构**: 调整目录和文件组织，使其更符合功能内聚的原则。
- **统一代码规范**: 确保所有文件和代码遵循统一的命名和格式规范。
- **降低系统复杂性**: 简化数据处理和组件配置逻辑，提高可维护性。

## 2. 清理阶段

### 2.1. 待删除文件

以下文件因功能冗余、代码过时或已被更好的方案替代，建议直接删除：

- **`src/components/visual-editor/core/data-source-manager.ts`**
  - **原因**: 功能与 `universal-data-source-manager.ts` 严重重叠，且设计较为陈旧。根据 `DOCS_ANALYSIS.md` 的证据，保留两者会造成代码冗余和维护混乱。
  - **操作**: 统一使用 `universal-data-source-manager.ts`，并彻底删除此文件及其所有引用。

- **`src/components/visual-editor/docs` 内的备份和临时文件**
  - **原因**: 这些文件（如 `architecture-design-backup.md`, `directory-structure-backup.md`）是开发过程中的历史产物，已失去参考价值。
  - **操作**: 逐一审查 `docs` 目录下的文件，删除所有明确为备份或临时的文档。

### 2.2. 待合并与重构文件

- **`src/components/visual-editor/core/component-api-config.ts`**
  - **原因**: 该文件通过一个巨大的硬编码对象来管理所有组件的API配置，违反了开闭原则，维护性差（见 `DOCS_ANALYSIS.md` 证据）。
  - **重构方向**: 废弃此文件。将数据源配置的责任下沉到每个 `WidgetDefinition`。每个组件定义应自行声明其所需的数据类型和默认参数，而不是依赖一个外部的、中心化的配置文件。

- **`src/components/visual-editor/core/card2-integration.ts`**
  - **原因**: 该文件是 `visual-editor` 与 `card2.1` 强耦合的核心（见 `DOCS_ANALYSIS.md` 证据），导致 `visual-editor` 无法独立复用。
  - **重构方向**: 移除此文件。在 `visual-editor` 外部创建一个 `Card2Adapter` 适配器。该适配器负责监听 `card2.1` 组件的注册，将其转换为 `WidgetDefinition`，然后再调用 `widgetRegistry.register` 方法进行注册。这样，`visual-editor` 本身将不再包含任何与 `card2.1` 相关的直接代码。

## 3. 重构阶段

### 3.1. 目录结构调整

**目标**: 实现按功能组织（Feature-Based）的目录结构。

**建议结构**:

```
visual-editor/
├── components/      # 通用UI组件 (如按钮、输入框等)
├── composables/     # 可复用的 Vue Composables (Hooks)
├── core/            # 核心引擎 (编辑器状态、渲染器管理等)
├── data-sources/    # 数据源相关 (管理器、类型定义、配置组件)
├── renderers/       # 渲染器实现 (Canvas, Gridstack)
├── widgets/         # 基础组件包 (文本、图片等)
├── settings/        # 属性配置面板相关
├── types/           # 全局共享类型
└── utils/           # 通用工具函数
```

### 3.2. 状态管理迁移

- **引入 Pinia**: 在项目中添加 Pinia 依赖。
- **创建 Stores**: 
  - `useEditorStore`: 管理画布状态、视口信息、当前模式等。
  - `useWidgetStore`: 管理组件的注册、选中状态和属性。
- **迁移逻辑**: 将 `state-manager.ts` 中的逻辑迁移到 Pinia Stores。特别地，`nodes` 和 `mode` 等全局状态可以移入 `useEditorStore`，而 `selectedIds` 和 `viewport` 等与UI交互紧密的状态，应优先作为组件内部状态管理，仅在必要时通过 Pinia 进行同步。此举旨在解决 `DOCS_ANALYSIS.md` 中指出的“中心化状态管理滥用”问题。

### 3.3. 统一命名规范

- **自动化工具**: 使用脚本或手动方式，将所有不符合 `kebab-case` 命名规范的文件和目录重命名。
- **代码审查**: 在 Code Review 阶段，严格检查命名规范的遵守情况。

## 4. 实施步骤

1. **备份项目**: 在开始重构前，务必完整备份当前项目。
2. **执行清理**: 按照“清理阶段”的计划，删除和合并相关文件。
3. **引入 Pinia**: 安装 Pinia 并建立基础的 Store 结构。
4. **重构状态管理**: 逐步将旧的状态管理逻辑迁移到 Pinia。
5. **调整目录结构**: 根据新的结构规划，移动文件和目录。
6. **重构数据源**: 简化数据源管理器，并抽象数据请求服务。
7. **解耦 Card 2.1**: 创建 `Card2Adapter` 并移除 `visual-editor` 内部的集成代码。
8. **统一命名**: 对所有文件和目录进行重命名。
9. **全面测试**: 对重构后的 `visual-editor` 进行全面的功能和回归测试。

## 5. 风险与应对

- **风险**: 重构范围较广，可能引入新的 Bug。
- **应对**: 
  - **分步进行**: 严格按照实施步骤，小步快跑，每完成一步都进行测试。
  - **充分测试**: 编写详细的测试用例，覆盖所有核心功能。
  - **代码审查**: 所有重构相关的代码变更都必须经过至少两位团队成员的审查。

## 6. 质量保证与回归测试

为了确保重构不影响现有功能的稳定性，我们将实施以下严格的质量保证策略：

### 6.1. 建立测试基准

在重构开始之前，我们将：
1.  **全面功能盘点**: 对 `visual-editor` 的所有现有功能点进行梳理，形成一份详细的功能清单。
2.  **创建回归测试用例**: 基于功能清单，编写一份详尽的回归测试用例集（Test Case），覆盖所有正常和异常的使用场景。
3.  **执行基准测试**: 运行完整的回归测试用例，记录所有测试结果，并对当前版本进行截图或录屏，作为后续比对的“黄金标准”。

### 6.2. 增量重构与持续测试

重构将严格遵循“小步快跑”的原则：
- **原子化提交**: 每个重构任务（如“迁移状态到 Pinia Store”）都将作为一个独立的、原子化的提交。提交信息必须清晰地描述变更内容。
- **即时反馈**: 在每次提交后，立即执行受影响范围内的回归测试用例，确保没有引入问题。这可以通过 Git Hooks 自动化部分流程。

### 6.3. 详细的回归测试计划

在每个阶段性重构完成后，都将执行一轮完整的回归测试。测试内容包括但不限于：

- **组件渲染测试**: 
  - 验证所有内置 Widget 和 Card 2.1 组件能否正常渲染。
  - 检查组件在不同尺寸和视口下的响应式布局是否正确。
- **数据源功能测试**:
  - 测试静态数据、设备数据、HTTP API 等所有类型的数据源是否能成功连接并获取数据。
  - 验证数据轮询机制是否按预期工作。
- **编辑器核心交互测试**:
  - 画布的拖拽、缩放、滚动。
  - Widget 的添加、删除、复制、移动和层级调整。
  - 属性面板的数值修改与实时预览。
- **性能基准测试**:
  - 对比重构前后的应用加载时间、大数据量下的渲染帧率和操作响应时间，确保性能没有下降。

### 6.4. 引入自动化测试 (建议)

为了长期保障代码质量，强烈建议在重构过程中逐步引入自动化测试：

- **单元测试**: 使用 `Vitest` 为核心的工具函数 (`utils`)、Composables (`hooks`) 和 Pinia Stores 编写单元测试，确保底层逻辑的正确性。
- **端到端 (E2E) 测试**: 使用 `Cypress` 或 `Playwright` 编写关键用户流程的 E2E 测试脚本，例如：
  - “用户登录后，成功创建一个新的仪表盘”
  - “在仪表盘中添加一个图表组件，并配置好数据源，图表正常显示”
  - “保存并重新加载仪表盘，所有配置均被正确还原”

### 6.5. 严格的代码审查 (Code Review)

- **双人审查**: 所有重构相关的 Pull Request 必须由至少两名熟悉业务的工程师进行审查。
- **关注回归风险**: Reviewer 的首要职责是评估代码变更是否可能引入功能性或性能上的回归风险，而不仅仅是检查代码风格。