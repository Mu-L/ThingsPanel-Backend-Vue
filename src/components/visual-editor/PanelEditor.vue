<script setup lang="ts">
import { computed, nextTick, onMounted, onUnmounted, ref, watch } from 'vue'
import { useDialog, useMessage, NDrawer, NDrawerContent } from 'naive-ui'
import { useFullscreen } from '@vueuse/core'
import { useAppStore } from '@/store/modules/app'
import FullScreen from '@/components/common/full-screen.vue'
import { $t } from '@/locales'
import { getBoard, PutBoard } from '@/service/api'
import { VisualEditorToolbar } from './components/toolbar'
import WidgetLibrary from './components/WidgetLibrary/WidgetLibrary.vue'
import { initializeSettings } from './settings'
import ConfigurationPanel from './configuration/ConfigurationPanel.vue'
import { configurationManager } from './configuration/ConfigurationManager'
import { CanvasRenderer, GridstackRenderer } from './renderers'
import { createEditor } from './hooks'
import { usePreviewMode } from './hooks/usePreviewMode'
import type { RendererType, VisualEditorWidget, GraphData } from './types'

// 导入数据源注册
// import './data-sources' // 临时注释，文件不存在

import { useVisualEditorIntegration } from '@/card2.1/hooks/useVisualEditorIntegration'
import { interactionManager } from '@/card2.1/core/interaction-manager'

// 初始化 Card 2.1 集成
useVisualEditorIntegration({
  autoInit: true,
  enableI18n: true
})

// 初始化设置面板
initializeSettings()

const dialog = useDialog()
const message = useMessage()
const appStore = useAppStore()

const props = defineProps<{ panelId: string }>()

const emit = defineEmits<{
  'state-manager-ready': [stateManager: any]
}>()

// 状态管理
const panelData = ref<Panel.Board>()
const fullui = ref()
const isEditing = ref(false) // 默认预览模式
const isSaving = ref(false)
const dataFetched = ref(false)
const hasChanges = ref(false)
const isUnmounted = ref(false)

// 交互测试相关代码已迁移到 visual-editor-details/index.vue

// 编辑器状态
const editorConfig = ref<any>({})
const preEditorConfig = ref<any>({})
const currentRenderer = ref<RendererType>('gridstack')

// 抽屉状态 - 初始状态：预览模式，抽屉关闭
const showLeftDrawer = ref(false) // 左侧组件库抽屉
const showRightDrawer = ref(false) // 右侧属性面板抽屉

// 拖拽状态管理
const isDragging = ref(false)
const draggedComponent = ref<string | null>(null)
const selectedNodeId = ref<string>('')
const showWidgetTitles = ref(true) // 总开关，默认显示标题

// 多数据源数据存储 - 以组件ID为键
const multiDataSourceStore = ref<Record<string, Record<string, any>>>({})

// 多数据源配置存储 - 以组件ID为键，存储完整配置信息
const multiDataSourceConfigStore = ref<Record<string, any>>({})

// 全屏功能
const { isFullscreen, toggle } = useFullscreen(fullui)

// 创建编辑器上下文
const editorContext = createEditor()
const { stateManager, addWidget, selectNode } = editorContext
const { setPreviewMode, isPreviewMode } = usePreviewMode()

const selectedWidget = computed<VisualEditorWidget | null>(() => {
  if (!selectedNodeId.value) return null
  const node = stateManager.nodes.find(node => node.id === selectedNodeId.value)
  if (node) {
    return node as VisualEditorWidget
  }
  return null
})

// 监听选中组件变化，添加防抖
let selectedWidgetTimer: NodeJS.Timeout | null = null
watch(
  () => selectedWidget.value,
  (newWidget, oldWidget) => {
    // 清除之前的定时器
    if (selectedWidgetTimer) {
      clearTimeout(selectedWidgetTimer)
    }

    // 设置新的定时器，防抖100ms
    selectedWidgetTimer = setTimeout(() => {
      // 只有当组件真正不同时才更新selectedNodeId
      if (newWidget?.id !== oldWidget?.id) {
        selectedNodeId.value = newWidget?.id || ''
        console.log('🔧 PanelEditor - 选中组件变化:', {
          oldId: oldWidget?.id,
          newId: newWidget?.id
        })
      }
    }, 100)
  },
  { deep: true }
)

// 状态管理辅助方法
const setState = (config: any) => {
  console.log('🔄 设置编辑器状态:', config)

  // 重置状态
  stateManager.reset()

  // 加载节点
  if (config.nodes && Array.isArray(config.nodes)) {
    config.nodes.forEach((node: any) => {
      stateManager.addNode(node as GraphData)
    })
  }

  // 加载视口设置
  if (config.viewport) {
    stateManager.updateViewport(config.viewport)
  }

  // 恢复渲染器类型和编辑器状态
  if (config.currentRenderer) {
    currentRenderer.value = config.currentRenderer
  }
  if (config.showWidgetTitles !== undefined) {
    showWidgetTitles.value = config.showWidgetTitles
  }
  if (config.showLeftDrawer !== undefined) {
    showLeftDrawer.value = config.showLeftDrawer
  }
  if (config.showRightDrawer !== undefined) {
    showRightDrawer.value = config.showRightDrawer
  }

  // 恢复编辑状态（可选，通常不保存编辑状态）
  if (config.isEditing !== undefined) {
    console.log('🔄 setState - 设置编辑状态:', {
      oldIsEditing: isEditing.value,
      newIsEditing: config.isEditing,
      willSetPreviewMode: !config.isEditing
    })
    isEditing.value = config.isEditing
    // 同步全局预览模式状态
    setPreviewMode(!config.isEditing)
  }
  if (config.selectedNodeId !== undefined) {
    selectedNodeId.value = config.selectedNodeId
  }
  if (config.isDragging !== undefined) {
    isDragging.value = config.isDragging
  }
  if (config.draggedComponent !== undefined) {
    draggedComponent.value = config.draggedComponent
  }

  // 🔥 关键修复：恢复所有组件的配置数据
  if (config.componentConfigurations) {
    try {
      console.log('🔄 setState - 恢复组件配置:', Object.keys(config.componentConfigurations))

      // 恢复每个组件的配置
      for (const [nodeId, nodeConfig] of Object.entries(config.componentConfigurations)) {
        if (nodeConfig && typeof nodeConfig === 'object') {
          try {
            // 🔥 关键修复：分离和恢复 multiDataSourceConfigStore 数据
            const typedConfig = nodeConfig as any

            // 检查是否有数据源配置需要恢复
            if (typedConfig.dataSource?.type === 'data-mapping' && typedConfig.dataSource?.config) {
              // 恢复到 multiDataSourceConfigStore
              multiDataSourceConfigStore.value[nodeId] = typedConfig.dataSource.config
              console.log(`🔄 setState - 恢复多数据源配置: ${nodeId}`, typedConfig.dataSource.config)
            }

            // 🔥 修复：保留完整配置，不删除 dataSource 字段
            configurationManager.setConfiguration(nodeId, typedConfig)

            console.log(`✅ setState - 恢复组件配置成功: ${nodeId}`)
          } catch (configError) {
            console.error(`❌ setState - 恢复组件配置失败: ${nodeId}`, configError)
            // 配置恢复失败不应阻止整个状态恢复过程
          }
        }
      }

      console.log('🎉 setState - 所有组件配置恢复完成')
    } catch (error) {
      console.error('💥 setState - 配置恢复过程失败:', error)
    }
  } else {
    console.log('ℹ️ setState - 没有组件配置需要恢复')
  }
}

const getState = () => {
  // 收集所有组件的配置数据
  const componentConfigurations: Record<string, any> = {}
  try {
    // 遍历所有节点，收集它们的配置
    for (const node of stateManager.nodes) {
      const config = configurationManager.getConfiguration(node.id)
      if (config) {
        // 🔥 关键修复：集成 multiDataSourceConfigStore 的数据
        const nodeId = node.id
        const multiDataSourceConfig = multiDataSourceConfigStore.value[nodeId]

        if (multiDataSourceConfig) {
          console.log(`🔍 getState - 检查multiDataSourceConfig: ${nodeId}`, {
            configExists: !!multiDataSourceConfig,
            configType: typeof multiDataSourceConfig,
            configKeys: Object.keys(multiDataSourceConfig),
            fullConfig: multiDataSourceConfig
          })

          // 将多数据源配置合并到 dataSource 字段中
          const enhancedConfig = {
            ...config,
            dataSource: {
              type: 'data-mapping',
              enabled: true,
              config: multiDataSourceConfig,
              metadata: {
                componentType: node.type,
                mappingType: 'json-path',
                updatedAt: Date.now()
              }
            }
          }
          componentConfigurations[nodeId] = enhancedConfig
          console.log(`💾 getState - 集成多数据源配置: ${nodeId}`, multiDataSourceConfig)
        } else {
          componentConfigurations[nodeId] = config
        }
      }
    }
    console.log('💾 getState - 收集到的组件配置:', Object.keys(componentConfigurations))
    console.log('💾 getState - multiDataSourceConfigStore 状态:', {
      storeKeys: Object.keys(multiDataSourceConfigStore.value),
      totalConfigs: Object.keys(multiDataSourceConfigStore.value).length
    })
  } catch (error) {
    console.error('💾 getState - 收集组件配置失败:', error)
  }

  return {
    nodes: stateManager.nodes,
    canvasConfig: editorConfig.value.canvasConfig || {},
    gridConfig: editorConfig.value.gridConfig || {},
    viewport: stateManager.viewport,
    mode: stateManager.mode,
    // 渲染器类型和编辑器状态
    currentRenderer: currentRenderer.value,
    showWidgetTitles: showWidgetTitles.value,
    // 抽屉状态（用于恢复编辑状态）
    showLeftDrawer: showLeftDrawer.value,
    showRightDrawer: showRightDrawer.value,
    // 新增：编辑模式状态
    isEditing: isEditing.value,
    // 新增：选中的节点ID
    selectedNodeId: selectedNodeId.value,
    // 新增：拖拽状态（可选）
    isDragging: isDragging.value,
    draggedComponent: draggedComponent.value,
    // 🔥 关键修复：包含所有组件的配置数据
    componentConfigurations: componentConfigurations
  }
}

// 获取面板数据 - 学习 fetchBroad 的写法
const fetchBoard = async () => {
  try {
    const { data } = await getBoard(props.panelId)
    // 检查组件是否已经卸载
    if (isUnmounted.value) {
      console.log('组件已卸载，取消数据处理')
      return
    }
    if (data) {
      panelData.value = data
      console.log('📊 获取面板数据成功:', data)

      if (data.config) {
        console.log('📝 解析现有配置:', data.config)
        const config = parseConfig(data.config)
        editorConfig.value = config.visualEditor || getDefaultConfig()
        preEditorConfig.value = JSON.parse(JSON.stringify(editorConfig.value))

        // 恢复渲染器类型和编辑器状态
        if (editorConfig.value.currentRenderer) {
          currentRenderer.value = editorConfig.value.currentRenderer
        }
        if (editorConfig.value.showWidgetTitles !== undefined) {
          showWidgetTitles.value = editorConfig.value.showWidgetTitles
        }
        if (editorConfig.value.showLeftDrawer !== undefined) {
          showLeftDrawer.value = editorConfig.value.showLeftDrawer
        }
        if (editorConfig.value.showRightDrawer !== undefined) {
          showRightDrawer.value = editorConfig.value.showRightDrawer
        }

        // 加载到编辑器
        setState(editorConfig.value)
        console.log('🎯 加载编辑器配置:', editorConfig.value)
      } else {
        console.log('📝 配置为空，使用默认配置')
        editorConfig.value = getDefaultConfig()
        preEditorConfig.value = JSON.parse(JSON.stringify(editorConfig.value))
        setState(editorConfig.value)
      }
      if (!isUnmounted.value) {
        dataFetched.value = true
        message.success($t('visualEditor.success'))
      }
    } else {
      console.warn('⚠️ 未获取到面板数据')
      if (!isUnmounted.value) {
        message.warning($t('visualEditor.warning'))
      }

      // 即使没有数据也要初始化默认配置
      editorConfig.value = getDefaultConfig()
      preEditorConfig.value = JSON.parse(JSON.stringify(editorConfig.value))
      setState(editorConfig.value)
      if (!isUnmounted.value) {
        dataFetched.value = true
      }
    }
  } catch (error: any) {
    console.error('获取面板数据失败:', error)
    if (!isUnmounted.value) {
      message.warning($t('visualEditor.warning'))
    }

    // 出错时也要初始化默认配置，让编辑器能正常工作
    editorConfig.value = getDefaultConfig()
    preEditorConfig.value = JSON.parse(JSON.stringify(editorConfig.value))
    setState(editorConfig.value)
    if (!isUnmounted.value) {
      dataFetched.value = true
    }
  }
}

// 解析配置
const parseConfig = (configString: string) => {
  try {
    const config = JSON.parse(configString)

    // 检查是否为新格式
    if (typeof config === 'object' && config.visualEditor) {
      // 验证配置格式
      const validatedConfig = validateConfig(config)
      return validatedConfig
    }

    // 兼容旧格式
    return {
      legacyComponents: Array.isArray(config) ? config : [],
      visualEditor: getDefaultConfig()
    }
  } catch (error: any) {
    console.warn('配置解析失败:', error)
    return {
      legacyComponents: [],
      visualEditor: getDefaultConfig()
    }
  }
}

// 验证配置格式
const validateConfig = (config: any) => {
  const defaultConfig = getDefaultConfig()

  // 确保 visualEditor 存在
  if (!config.visualEditor) {
    config.visualEditor = defaultConfig
    return config
  }

  // 验证并补充缺失的配置项
  const visualEditor = config.visualEditor

  // 确保基本配置项存在
  if (!visualEditor.nodes) visualEditor.nodes = defaultConfig.nodes
  if (!visualEditor.canvasConfig) visualEditor.canvasConfig = defaultConfig.canvasConfig
  if (!visualEditor.gridConfig) visualEditor.gridConfig = defaultConfig.gridConfig
  if (!visualEditor.viewport) visualEditor.viewport = defaultConfig.viewport
  if (!visualEditor.currentRenderer) visualEditor.currentRenderer = defaultConfig.currentRenderer
  if (!visualEditor.showWidgetTitles) visualEditor.showWidgetTitles = defaultConfig.showWidgetTitles
  if (!visualEditor.showLeftDrawer) visualEditor.showLeftDrawer = defaultConfig.showLeftDrawer
  if (!visualEditor.showRightDrawer) visualEditor.showRightDrawer = defaultConfig.showRightDrawer

  // 确保 legacyComponents 存在
  if (!config.legacyComponents) {
    config.legacyComponents = []
  }

  // 执行配置迁移
  const migratedConfig = migrateConfig(config)

  return migratedConfig
}

// 配置迁移函数
const migrateConfig = (config: any) => {
  const visualEditor = config.visualEditor

  // 检查版本并执行迁移
  const version = visualEditor.metadata?.version || '0.0.0'

  // 从 v0.x 迁移到 v1.0
  if (version.startsWith('0.')) {
    console.log('🔄 执行配置迁移: v0.x -> v1.0')

    // 添加缺失的配置项
    if (!visualEditor.currentRenderer) {
      visualEditor.currentRenderer = 'gridstack'
    }
    if (!visualEditor.showWidgetTitles) {
      visualEditor.showWidgetTitles = true
    }
    if (!visualEditor.showLeftDrawer) {
      visualEditor.showLeftDrawer = false
    }
    if (!visualEditor.showRightDrawer) {
      visualEditor.showRightDrawer = false
    }

    // 更新版本信息
    if (!visualEditor.metadata) {
      visualEditor.metadata = {}
    }
    visualEditor.metadata.version = '1.0.0'
    visualEditor.metadata.migratedAt = Date.now()
  }

  return config
}

// 默认配置
const getDefaultConfig = () => ({
  nodes: [],
  canvasConfig: {
    width: 1200,
    height: 800,
    showGrid: true,
    backgroundColor: '#f5f5f5'
  },
  gridConfig: {
    colNum: 24,
    rowHeight: 80,
    margin: [10, 10],
    isDraggable: true,
    isResizable: true,
    staticGrid: false
  },
  viewport: {},
  // 默认渲染器类型和编辑器状态
  currentRenderer: 'gridstack' as RendererType,
  showWidgetTitles: true,
  showLeftDrawer: false,
  showRightDrawer: false,
  // 新增：默认编辑状态
  isEditing: false,
  selectedNodeId: '',
  isDragging: false,
  draggedComponent: null
})

// 渲染器选项
const rendererOptions = computed(() => [
  { label: $t('visualEditor.canvas'), value: 'canvas' as RendererType },
  { label: $t('visualEditor.gridstack'), value: 'gridstack' as RendererType }
])

// 工具栏事件处理
const handleModeChange = (mode: 'edit' | 'preview') => {
  console.log('🔄 模式切换请求:', { from: isPreviewMode ? 'preview' : 'edit', to: mode })

  if (mode === 'edit') {
    console.log('📝 切换到编辑模式')
    isEditing.value = true
    setPreviewMode(false) // 同步全局预览模式

    // 🎯 改进用户体验：进入编辑模式时自动打开左侧组件库抽屉
    if (!showLeftDrawer.value) {
      console.log('🔧 自动打开左侧组件库抽屉')
      showLeftDrawer.value = true
    }
  } else {
    console.log('👁️ 切换到预览模式')
    const currentState = getState()
    if (JSON.stringify(currentState) !== JSON.stringify(preEditorConfig.value)) {
      console.log('⚠️ 有未保存的更改，显示确认对话框')
      dialog.warning({
        title: $t('card.quitWithoutSave'),
        positiveText: $t('device_template.confirm'),
        negativeText: $t('common.cancel'),
        onPositiveClick: () => {
          // 用户确认退出，重置配置
          console.log('✅ 用户确认退出，重置配置')
          isEditing.value = false
          setPreviewMode(true) // 同步全局预览模式
          // 退出编辑模式时关闭所有抽屉
          showLeftDrawer.value = false
          showRightDrawer.value = false
          // 清空选中状态
          selectedNodeId.value = ''
          // 重要：确保editorConfig中的isEditing为false，避免状态冲突
          editorConfig.value = { ...preEditorConfig.value, isEditing: false }
          // 重要：在调用setState之前，确保preEditorConfig中的isEditing为false
          const resetConfig = { ...preEditorConfig.value, isEditing: false }
          setState(resetConfig)
        },
        onNegativeClick: () => {
          // 用户取消退出，保持当前状态，不做任何操作
          console.log('❌ 用户取消退出编辑模式，保持当前配置')
        }
      })
    } else {
      // 没有未保存的更改，直接退出编辑模式
      console.log('✅ 没有未保存的更改，直接退出编辑模式')
      isEditing.value = false
      setPreviewMode(true) // 同步全局预览模式
      // 退出编辑模式时关闭所有抽屉
      showLeftDrawer.value = false
      showRightDrawer.value = false
      // 清空选中状态
      selectedNodeId.value = ''
    }
  }

  console.log('🎯 模式切换完成:', { isEditing: isEditing.value, isPreviewMode: isPreviewMode, mode })
}

// 抽屉控制事件处理
const handleToggleLeftDrawer = () => {
  showLeftDrawer.value = !showLeftDrawer.value
  hasChanges.value = true
}

const handleToggleRightDrawer = () => {
  showRightDrawer.value = !showRightDrawer.value
  hasChanges.value = true
}

// 拖拽事件处理
const handleDragStart = (componentType: string) => {
  console.log('🎯 开始拖拽组件:', componentType)
  isDragging.value = true
  draggedComponent.value = componentType
}

const handleDragEnd = () => {
  console.log('🎯 结束拖拽')
  isDragging.value = false
  draggedComponent.value = null
}

const handleRendererChange = (renderer: RendererType) => {
  console.log('🔄 渲染器变更:', { old: currentRenderer.value, new: renderer })
  currentRenderer.value = renderer
  hasChanges.value = true
}

const handleAddWidget = async (widget: { type: string }) => {
  try {
    const widgetType = widget.type

    await addWidget(widgetType)
    hasChanges.value = true
    message.success($t('visualEditor.addWidgetSuccess', { type: widgetType }))
  } catch (error: any) {
    const widgetType = widget.type
    console.error(`❌ 添加组件失败 [${widgetType}]:`, error)
    message.error($t('visualEditor.addWidgetFailed', { type: widgetType, error: error.message || '未知错误' }))
  }
}

const handleClearAll = () => {
  stateManager.reset()
  hasChanges.value = true
  message.success($t('visualEditor.clearAllSuccess'))
}

// 导入导出处理
const handleImportConfig = (config: Record<string, any>) => {
  try {
    console.log('导入配置:', config)

    // 验证配置格式
    if (config && typeof config === 'object') {
      // 如果是新格式配置
      if (config.visualEditor) {
        editorConfig.value = config.visualEditor
        setState(config.visualEditor)
      }
      // 如果是直接的编辑器配置
      else if (config.nodes || config.canvasConfig) {
        editorConfig.value = config
        setState(config)
      }
      // 否则当作旧格式处理
      else {
        const newConfig = getDefaultConfig()
        editorConfig.value = newConfig
        setState(newConfig)
      }

      hasChanges.value = true
      message.success($t('visualEditor.configImportSuccess'))
    } else {
      throw new Error('无效的配置格式')
    }
  } catch (error: any) {
    console.error('导入配置失败:', error)
    message.error($t('visualEditor.configImportFailed', { error: error.message || '未知错误' }))
  }
}

const handleExportConfig = () => {
  try {
    const currentState = getState()
    const exportConfig = {
      visualEditor: {
        ...currentState,
        metadata: {
          version: '1.0.0',
          exportedAt: Date.now(),
          editorType: 'visual-editor',
          // 导出时的面板信息
          panelInfo: {
            id: props.panelId,
            name: panelData.value?.name || '',
            homeFlag: panelData.value?.home_flag || false,
            exportedAt: Date.now()
          },
          // 导出时的编辑器状态
          exportInfo: {
            totalNodes: currentState.nodes.length,
            rendererType: currentState.currentRenderer,
            hasGridConfig: !!currentState.gridConfig,
            hasCanvasConfig: !!currentState.canvasConfig,
            showWidgetTitles: currentState.showWidgetTitles
          }
        }
      }
    }

    // 创建下载链接
    const blob = new Blob([JSON.stringify(exportConfig, null, 2)], {
      type: 'application/json'
    })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `panel-config-${panelData.value?.name || 'unnamed'}-${Date.now()}.json`
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)

    message.success($t('visualEditor.configExportSuccess'))
  } catch (error: any) {
    console.error('导出配置失败:', error)
    message.error($t('visualEditor.configExportFailed', { error: error.message || '未知错误' }))
  }
}

// 视图控制事件
const handleToggleWidgetTitles = (value: boolean) => {
  showWidgetTitles.value = value
  hasChanges.value = true
}

const handleGridConfigChange = (newGridConfig: any) => {
  console.log('🔧 PanelEditor - 网格配置变更:', {
    oldConfig: editorConfig.value.gridConfig,
    newConfig: newGridConfig
  })

  editorConfig.value.gridConfig = { ...editorConfig.value.gridConfig, ...newGridConfig }
  hasChanges.value = true

  console.log('🔧 PanelEditor - 更新后配置:', editorConfig.value.gridConfig)
  console.log('🔧 PanelEditor - 当前完整配置:', editorConfig.value)
}

const handleGridstackConfigChange = (newGridConfig: any) => {
  console.log('🔧 PanelEditor - 工具栏网格配置变更:', {
    oldConfig: editorConfig.value.gridConfig,
    newConfig: newGridConfig
  })

  editorConfig.value.gridConfig = { ...editorConfig.value.gridConfig, ...newGridConfig }
  hasChanges.value = true

  console.log('🔧 PanelEditor - 更新后配置:', editorConfig.value.gridConfig)
  console.log('🔧 PanelEditor - 当前完整配置:', editorConfig.value)
}

const handleCanvasConfigChange = (newCanvasConfig: any) => {
  console.log('🔧 PanelEditor - 画布配置变更:', {
    oldConfig: editorConfig.value.canvasConfig,
    newConfig: newCanvasConfig
  })

  editorConfig.value.canvasConfig = { ...editorConfig.value.canvasConfig, ...newCanvasConfig }
  hasChanges.value = true

  console.log('🔧 PanelEditor - 更新后配置:', editorConfig.value.canvasConfig)
}

// 交互测试方法已迁移到上层组件 visual-editor-details/index.vue

/**
 * 处理多数据源数据更新
 */
const handleMultiDataSourceUpdate = (widgetId: string, dataSources: Record<string, any>) => {
  console.log(`🔧 PanelEditor - 多数据源数据更新: ${widgetId}`, dataSources)

  // 存储数据源数据
  multiDataSourceStore.value[widgetId] = dataSources

  // 标记有变化
  hasChanges.value = true

  console.log(`✅ PanelEditor - 多数据源数据已存储:`, multiDataSourceStore.value)
}

/**
 * 处理多数据源配置更新
 */
const handleMultiDataSourceConfigUpdate = (widgetId: string, config: any) => {
  console.log(`🔧 [DEBUG-Config] 多数据源配置更新:`, {
    widgetId,
    hasDataSourceBindings: !!config.dataSourceBindings,
    bindingKeys: config.dataSourceBindings ? Object.keys(config.dataSourceBindings) : [],
    config
  })

  // 🔍 详细调试存储前后的数据
  console.log(`🔍 [Store-Before] 存储前的 multiDataSourceConfigStore:`, {
    beforeKeys: Object.keys(multiDataSourceConfigStore.value),
    beforeData: multiDataSourceConfigStore.value[widgetId]
  })

  // 存储配置信息
  multiDataSourceConfigStore.value[widgetId] = config

  console.log(`🔍 [Store-After] 存储后的 multiDataSourceConfigStore:`, {
    afterKeys: Object.keys(multiDataSourceConfigStore.value),
    afterData: multiDataSourceConfigStore.value[widgetId],
    isDataCorrect:
      !!multiDataSourceConfigStore.value[widgetId]?.dataSourceBindings &&
      Object.keys(multiDataSourceConfigStore.value[widgetId].dataSourceBindings).length > 0
  })

  // 标记有变化
  hasChanges.value = true

  console.log(`🔧 [DEBUG-Config] 配置存储完成:`, {
    widgetId,
    storeKeys: Object.keys(multiDataSourceConfigStore.value),
    totalConfigs: Object.keys(multiDataSourceConfigStore.value).length
  })
}

/**
 * 🔥 新增：处理配置面板请求当前数据
 * 提供组件当前运行时数据给配置面板，实现内存数据优先原则
 */
const handleRequestCurrentData = (widgetId: string) => {
  console.log('🔄 [PanelEditor] 处理当前数据请求:', widgetId)

  // 获取当前运行时配置数据
  const currentConfig = multiDataSourceConfigStore.value[widgetId]

  if (currentConfig) {
    console.log('✅ [PanelEditor] 提供当前运行时配置数据:', currentConfig)

    // 通过 ConfigurationManager 临时更新配置，让配置面板可以获取到
    const tempDataSourceConfig = {
      type: 'data-mapping',
      enabled: true,
      config: currentConfig,
      metadata: {
        componentType: selectedWidget.value?.type || 'unknown',
        mappingType: 'json-path',
        updatedAt: Date.now(),
        isRuntime: true // 标记为运行时数据
      }
    }

    // 临时更新 ConfigurationManager 中的数据源配置
    configurationManager.updateConfiguration(widgetId, 'dataSource', tempDataSourceConfig)

    console.log('🔄 [PanelEditor] 已更新 ConfigurationManager 为当前运行时数据')
  } else {
    console.log('ℹ️ [PanelEditor] 没有找到当前运行时配置数据，将使用默认数据')
  }
}

const handleZoomIn = () => {
  // TODO: 实现缩放功能
  console.log('放大视图')
}

const handleZoomOut = () => {
  // TODO: 实现缩放功能
  console.log('缩小视图')
}

const handleResetZoom = () => {
  // TODO: 实现重置缩放功能
  console.log('重置缩放')
}

const handleUndo = () => {
  // TODO: 实现撤销功能
  console.log('撤销操作')
}

const handleRedo = () => {
  // TODO: 实现重做功能
  console.log('重做操作')
}

// 渲染器事件处理
const handleRendererReady = () => {
  console.log('✅ 渲染器已准备就绪')
}

const handleRendererError = (error: Error) => {
  console.error('❌ 渲染器错误:', error)
  message.error($t('visualEditor.rendererLoadFailed', { error: error.message }))
}

const handleNodeSelect = (nodeId: string) => {
  selectedNodeId.value = nodeId
  selectNode(nodeId)
  // 节点选择通常不触发保存，但可以标记为有变化
  // hasChanges.value = true
}

const handleRequestSettings = (nodeId: string) => {
  if (nodeId) {
    selectedNodeId.value = nodeId
    selectNode(nodeId)
    showRightDrawer.value = true
  }
}

const handleCanvasClick = () => {
  selectedNodeId.value = ''
  selectNode('')
  // 取消选中时可以选择性隐藏属性面板（或保持展开）
  // rightCollapsed.value = true
}

// 保存面板
const handleSave = async () => {
  // 检查是否为Canvas渲染器，如果是则显示开发中提示
  if (currentRenderer.value === 'canvas') {
    message.warning('Canvas渲染器功能正在开发中，暂不支持保存')
    console.warn('Canvas功能尚未完成，无法保存')
    return
  }

  isSaving.value = true
  try {
    const currentState = getState()

    // 🔍 保存过程调试
    console.log('💾 [SAVE] 开始保存，getState返回:', {
      nodesCount: currentState.nodes?.length || 0,
      hasComponentConfigurations: !!currentState.componentConfigurations,
      componentConfigurationKeys: currentState.componentConfigurations
        ? Object.keys(currentState.componentConfigurations)
        : [],
      multiDataSourceConfigStoreKeys: Object.keys(multiDataSourceConfigStore.value),
      fullState: currentState
    })

    // 解析现有配置
    let existingConfig: any = {}
    if (panelData.value?.config) {
      try {
        existingConfig = parseConfig(panelData.value.config)
      } catch (error: any) {
        console.warn('解析现有配置失败:', error)
      }
    }

    // 先构建基础配置（不包含 configSize）
    const baseConfig = {
      legacyComponents: existingConfig.legacyComponents || [],
      visualEditor: {
        ...currentState,
        metadata: {
          version: '1.0.0',
          updatedAt: Date.now(),
          editorType: 'visual-editor',
          // 面板基本信息
          panelInfo: {
            id: props.panelId,
            name: panelData.value?.name || '',
            homeFlag: panelData.value?.home_flag || false,
            createdAt: panelData.value?.created_at || Date.now(),
            updatedAt: Date.now()
          },
          // 编辑器版本信息
          editorVersion: '1.0.0',
          // 渲染器信息
          rendererInfo: {
            type: currentRenderer.value,
            version: '1.0.0',
            features: ['drag', 'resize', 'grid', 'canvas']
          },
          // 配置统计信息
          stats: {
            totalNodes: currentState.nodes.length,
            card2Nodes: currentState.nodes.filter((node: any) => node.metadata?.isCard2Component).length,
            legacyNodes: currentState.nodes.filter((node: any) => !node.metadata?.isCard2Component).length,
            hasGridConfig: !!currentState.gridConfig,
            hasCanvasConfig: !!currentState.canvasConfig,
            configSize: 0 // 初始值，稍后会被更新
          }
        }
      }
    }

    // 现在可以安全地计算配置大小
    const configSize = JSON.stringify(baseConfig).length
    baseConfig.visualEditor.metadata.stats.configSize = configSize

    console.log('💾 保存配置统计:', baseConfig.visualEditor.metadata.stats)

    const { error } = await PutBoard({
      id: props.panelId,
      config: JSON.stringify(baseConfig),
      name: panelData.value?.name,
      home_flag: panelData.value?.home_flag
    })

    if (!error) {
      preEditorConfig.value = JSON.parse(JSON.stringify(currentState))
      hasChanges.value = false
      message.success($t('page.dataForward.saveSuccess'))
    } else {
      message.error($t('page.dataForward.saveFailed') || '保存失败')
    }
  } catch (err: any) {
    message.error($t('page.dataForward.saveFailed') || '保存失败')
    console.error('保存失败:', err)
  } finally {
    isSaving.value = false
  }
}

// 监听状态变化，自动设置 hasChanges
watch(
  [
    () => currentRenderer.value,
    () => showWidgetTitles.value,
    () => showLeftDrawer.value,
    () => showRightDrawer.value,
    () => editorConfig.value.gridConfig,
    () => editorConfig.value.canvasConfig,
    () => stateManager.nodes
  ],
  () => {
    // 只有在数据加载完成后才监听变化
    if (dataFetched.value && !isUnmounted.value) {
      hasChanges.value = true
    }
  },
  { deep: true }
)

// 学习 PanelManage 的 onMounted 写法
onMounted(async () => {
  // 初始化时同步预览模式状态
  setPreviewMode(!isEditing.value)

  // 先加载面板数据
  await fetchBoard()

  // 面板数据加载完成后，检查多数据源配置状态
  await nextTick() // 确保DOM更新完成
  restoreMultiDataSourceConfigs() // 现在只做状态检查
  
  // 发出状态管理器就绪事件，供上层组件使用
  emit('state-manager-ready', stateManager)
})

/**
 * V6: 恢复多数据源配置（已弃用）
 * 🔥 修复说明：配置恢复现在已集成到 setState 方法中
 * 这个函数保留用于调试和状态检查
 */
const restoreMultiDataSourceConfigs = () => {
  console.log('🔧 [PanelEditor] 检查多数据源配置状态（已集成到setState）...')
  console.log('🔧 [PanelEditor] 当前状态检查:', {
    hasStateManager: !!stateManager,
    nodesCount: stateManager?.nodes?.length || 0,
    dataFetched: dataFetched.value,
    currentMultiDataSourceConfigStore: Object.keys(multiDataSourceConfigStore.value).length
  })

  if (!stateManager?.nodes || stateManager.nodes.length === 0) {
    console.log('🔧 [PanelEditor] 无图表节点，跳过检查')
    return
  }

  // 🔥 配置恢复现在在 setState 中完成，这里只做状态报告
  console.log('✅ [PanelEditor] 配置恢复已通过 setState 完成')
  return

  const restored: Record<string, any> = {}
  let restoredCount = 0
  let skippedCount = 0

  // 遍历所有节点，从ConfigurationManager恢复配置
  stateManager.nodes.forEach(node => {
    const widgetId = node.id
    console.log(`🔍 [PanelEditor] 检查组件 ${widgetId} 的配置...`)

    try {
      const configuration = configurationManager.getConfiguration(widgetId)
      console.log(`📋 [PanelEditor] 组件 ${widgetId} 的完整配置:`, configuration)

      // 检查是否有V6数据源配置
      if (
        (configuration?.dataSource?.type === 'data-mapping' ||
          configuration?.dataSource?.type === 'data-source-bindings') &&
        configuration.dataSource.config
      ) {
        restored[widgetId] = configuration.dataSource.config
        restoredCount++

        console.log(`🔄 [PanelEditor] 恢复组件 ${widgetId} 的数据源配置:`, {
          type: configuration.dataSource.type,
          config: configuration.dataSource.config,
          hasDataSourceBindings: !!configuration.dataSource.config.dataSourceBindings,
          bindingsKeys: Object.keys(configuration.dataSource.config.dataSourceBindings || {})
        })
      } else {
        console.log(`⏭️ [PanelEditor] 跳过组件 ${widgetId}:`, {
          hasConfiguration: !!configuration,
          hasDataSource: !!configuration?.dataSource,
          dataSourceType: configuration?.dataSource?.type,
          hasConfig: !!configuration?.dataSource?.config
        })
        skippedCount++
      }
    } catch (error) {
      console.warn(`⚠️ [PanelEditor] 恢复组件 ${widgetId} 配置失败:`, error)
      skippedCount++
    }
  })

  // 批量更新multiDataSourceConfigStore
  if (restoredCount > 0) {
    const oldStore = { ...multiDataSourceConfigStore.value }
    multiDataSourceConfigStore.value = { ...multiDataSourceConfigStore.value, ...restored }

    console.log(`✅ [PanelEditor] 数据源配置恢复完成:`, {
      restoredCount,
      skippedCount,
      totalNodes: stateManager.nodes.length,
      oldStoreKeys: Object.keys(oldStore),
      newStoreKeys: Object.keys(multiDataSourceConfigStore.value),
      restoredData: restored
    })

    // 🔥 关键修复：同时恢复数据源数据和配置
    console.log('🔄 [PanelEditor] 恢复数据源数据和配置...')

    const restoredData: Record<string, any> = {}

    Object.entries(restored).forEach(([widgetId, config]) => {
      console.log(`📤 [PanelEditor] 触发组件 ${widgetId} 的数据源配置更新:`, config)

      // 从配置中恢复数据源数据
      if (config.dataSourceBindings) {
        const widgetData: Record<string, any> = {}
        Object.entries(config.dataSourceBindings).forEach(([dataSourceKey, binding]: [string, any]) => {
          if (binding.rawData) {
            try {
              widgetData[dataSourceKey] = JSON.parse(binding.rawData)
            } catch (error) {
              console.warn(`⚠️ [PanelEditor] 解析组件 ${widgetId} 数据源 ${dataSourceKey} 失败:`, error)
            }
          }
        })

        if (Object.keys(widgetData).length > 0) {
          restoredData[widgetId] = widgetData
          console.log(`📊 [PanelEditor] 恢复组件 ${widgetId} 的数据:`, widgetData)
        }
      }

      // 触发配置更新事件，让组件立即接收到配置
      handleMultiDataSourceConfigUpdate(widgetId, config)
    })

    // 批量更新 multiDataSourceStore
    if (Object.keys(restoredData).length > 0) {
      multiDataSourceStore.value = { ...multiDataSourceStore.value, ...restoredData }
      console.log(`✅ [PanelEditor] 数据源数据恢复完成:`, restoredData)
    }

    console.log('✅ [PanelEditor] 数据源配置更新事件已全部触发')
  } else {
    console.log(`🔧 [PanelEditor] 数据源配置恢复结果:`, {
      restoredCount: 0,
      skippedCount,
      totalNodes: stateManager.nodes.length,
      reason: '无V6数据映射配置需要恢复'
    })
  }
}

// 组件卸载时的清理工作
onUnmounted(() => {
  isUnmounted.value = true
  // 清理定时器
  if (selectedWidgetTimer) {
    clearTimeout(selectedWidgetTimer)
  }
})
</script>

<template>
  <div class="w-full px-5 py-5">
    <!-- 页面标题栏 -->
    <div
      v-show="!appStore.fullContent"
      class="flex items-center justify-between border-b border-gray-200 px-10px pb-3 dark:border-gray-200/10"
    >
      <div>
        <NSpace align="center">
          <span class="text-14px font-medium line-height-normal">
            {{ $t('card.dashboard') }}：{{ panelData?.name }}
          </span>
        </NSpace>
      </div>
      <NSpace align="center">
        <FullScreen :full="isFullscreen" @click="toggle" />
      </NSpace>
    </div>

    <!-- 编辑器区域 -->
    <div ref="fullui" class="h-edit-area flex bg-white">
      <div v-if="!dataFetched" class="h-full flex items-center justify-center w-full">
        <n-spin size="large">
          <template #description>
            {{ $t('visualEditor.loading') }}
          </template>
        </n-spin>
      </div>

      <div v-else class="panel-editor w-full h-full flex flex-col">
        <!-- 工具栏 -->
        <div class="toolbar-container flex-shrink-0">
          <VisualEditorToolbar
            v-if="dataFetched && !isUnmounted"
            :key="`toolbar-${currentRenderer}-${isPreviewMode ? 'preview' : 'edit'}`"
            :mode="isPreviewMode ? 'preview' : 'edit'"
            :current-renderer="currentRenderer"
            :available-renderers="rendererOptions"
            :is-saving="isSaving"
            :has-changes="hasChanges"
            :show-left-drawer="showLeftDrawer"
            :show-right-drawer="showRightDrawer"
            :gridstack-config="editorConfig.gridConfig"
            :canvas-config="editorConfig.canvasConfig"
            @mode-change="handleModeChange"
            @renderer-change="handleRendererChange"
            @save="handleSave"
            @import="handleImportConfig"
            @export="handleExportConfig"
            @import-config="handleImportConfig"
            @export-config="handleExportConfig"
            @undo="handleUndo"
            @redo="handleRedo"
            @clear-all="handleClearAll"
            @zoom-in="handleZoomIn"
            @zoom-out="handleZoomOut"
            @reset-zoom="handleResetZoom"
            @toggle-left-drawer="handleToggleLeftDrawer"
            @toggle-right-drawer="handleToggleRightDrawer"
            @gridstack-config-change="handleGridstackConfigChange"
            @canvas-config-change="handleCanvasConfigChange"
          />

        </div>

        <!-- 主内容区域 -->
        <div class="main-container flex-1 relative overflow-hidden" :class="{ dragging: isDragging }">

          <!-- 中央画布 -->
          <div class="canvas-container h-full w-full" @click="handleCanvasClick">
            <!-- 动态渲染器 -->
            <CanvasRenderer
              v-if="currentRenderer === 'canvas' && dataFetched && !isUnmounted"
              key="canvas-renderer"
              :readonly="isPreviewMode"
              :show-widget-titles="showWidgetTitles"
              class="renderer-container"
              @ready="handleRendererReady"
              @error="handleRendererError"
              @node-select="handleNodeSelect"
              @canvas-click="handleCanvasClick"
              @request-settings="handleRequestSettings"
            />
            <GridstackRenderer
              v-else-if="currentRenderer === 'gridstack' && dataFetched && !isUnmounted"
              key="gridstack-renderer"
              :readonly="isPreviewMode"
              :show-widget-titles="showWidgetTitles"
              :grid-config="editorConfig.gridConfig"
              :multi-data-source-store="multiDataSourceStore"
              :multi-data-source-config-store="multiDataSourceConfigStore"
              class="renderer-container"
              @ready="handleRendererReady"
              @error="handleRendererError"
              @node-select="handleNodeSelect"
              @canvas-click="handleCanvasClick"
              @request-settings="handleRequestSettings"
            />
          </div>

          <!-- 左侧组件库抽屉 -->
          <NDrawer
            v-model:show="showLeftDrawer"
            :width="320"
            placement="left"
            :show-mask="false"
            :mask-closable="true"
            :closable="true"
            :auto-focus="false"
            :z-index="1000"
            :trap-focus="false"
          >
            <NDrawerContent :title="$t('visualEditor.componentLibrary')" :native-scrollbar="false">
              <WidgetLibrary @add-widget="handleAddWidget" @drag-start="handleDragStart" @drag-end="handleDragEnd" />
            </NDrawerContent>
          </NDrawer>

          <!-- 右侧属性面板抽屉 -->
          <NDrawer
            v-model:show="showRightDrawer"
            :width="450"
            placement="right"
            :show-mask="true"
            :mask-closable="true"
            :closable="true"
            :auto-focus="false"
            :z-index="1000"
            :trap-focus="false"
          >
            <NDrawerContent :title="$t('visualEditor.propertySettings')" :native-scrollbar="false">
              <ConfigurationPanel
                :selected-widget="selectedWidget"
                :show-widget-titles="showWidgetTitles"
                :grid-config="editorConfig.gridConfig"
                @toggle-widget-titles="handleToggleWidgetTitles"
                @grid-config-change="handleGridConfigChange"
                @multi-data-source-update="handleMultiDataSourceUpdate"
                @multi-data-source-config-update="handleMultiDataSourceConfigUpdate"
                @request-current-data="handleRequestCurrentData"
              />
            </NDrawerContent>
          </NDrawer>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.panel-editor {
  min-height: 600px;
}

.h-edit-area {
  height: calc(100% - 30px);
}

/* 画布容器 */
.canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-color: var(--n-body-color);
}

.renderer-container {
  width: 100%;
  height: 100%;
}

/* 拖拽状态样式 */
.main-container.dragging .n-drawer {
  opacity: 0.3;
  transition: opacity 0.2s ease;
}

.main-container.dragging .n-drawer-mask {
  pointer-events: none;
}

/* 确保拖拽元素在最顶层 */
.dragging-element {
  position: fixed;
  z-index: 9999 !important;
  pointer-events: none;
}

/* 抽屉内容优化 */
:deep(.n-drawer-content) {
  height: 100%;
}

:deep(.n-drawer-content .n-drawer-content__content) {
  padding: 0;
  height: 100%;
}

/* 左侧抽屉特殊样式 - 半透明效果，不影响拖拽 */
:deep(.n-drawer--left) {
  background-color: rgba(250, 250, 250, 0.9) !important;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

:deep(.n-drawer--left .n-drawer-content) {
  background-color: rgba(250, 250, 250, 0.9) !important;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

/* 暗色主题下的左侧抽屉 */
:deep(.dark .n-drawer--left) {
  background-color: rgba(37, 37, 37, 0.9) !important;
}

:deep(.dark .n-drawer--left .n-drawer-content) {
  background-color: rgba(37, 37, 37, 0.9) !important;
}

/* 右侧抽屉增强阴影效果 */
:deep(.n-drawer--right) {
  box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
}

/* 工具栏容器 */
.toolbar-container {
  border-bottom: 1px solid #e0e0e0;
  background-color: #fff;
}

/* 响应式设计 */
@media (max-width: 768px) {
  .panel-editor {
    min-height: 400px;
  }
}

</style>
