<template>
  <div ref="fabricContainer" class="fabric-canvas-container">
    <!-- Fabric.js 依赖检查 -->
    <div v-if="!fabricAvailable" class="fabric-missing-container">
      <n-result status="warning" title="需要安装 Fabric.js" description="Fabric Canvas 渲染器需要 Fabric.js 依赖才能正常工作">
        <template #footer>
          <n-space vertical :size="16">
            <n-alert type="info" :show-icon="false">
              <strong>安装命令：</strong>
              <n-code>pnpm add fabric</n-code>
            </n-alert>
            <n-space>
              <n-button type="primary" @click="checkFabricAvailability">
                重新检测
              </n-button>
              <n-button @click="switchToSimpleRenderer">
                切换到简单渲染器
              </n-button>
            </n-space>
          </n-space>
        </template>
      </n-result>
    </div>

    <!-- Fabric Canvas 渲染区域 -->
    <div v-else class="fabric-canvas-wrapper">
      <!-- 工具栏信息 -->
      <div class="fabric-info-bar">
        <n-space align="center">
          <n-tag type="success">Fabric.js Canvas</n-tag>
          <n-text depth="3">节点数量: {{ nodes.length }}</n-text>
          <n-text depth="3">画布尺寸: {{ canvasSize.width }}×{{ canvasSize.height }}</n-text>
          <n-text v-if="props.readonly" type="warning">只读模式</n-text>
        </n-space>
      </div>

      <!-- Fabric 画布容器 -->
      <div ref="canvasContainer" class="fabric-canvas-area"></div>
    </div>
  </div>
</template>

<script setup lang="ts">
/**
 * Fabric.js Canvas 组件
 * 基于 Fabric.js 6.7.1 的高级画布渲染器
 */

import { ref, onMounted, onUnmounted, watch, nextTick, computed } from 'vue'
import { useMessage } from 'naive-ui'
import { NResult, NSpace, NAlert, NCode, NButton, NTag, NText } from 'naive-ui'
import FabricRenderer, { type FabricRendererConfig } from './FabricRenderer'
import type { VisualEditorWidget } from '@/components/visual-editor/types'

interface Props {
  graphData: any  // 来自外层的节点数据
  readonly?: boolean
  canvasConfig?: FabricRendererConfig
  showWidgetTitles?: boolean
  multiDataSourceStore?: Record<string, Record<string, any>>
  multiDataSourceConfigStore?: Record<string, any>
}

const props = withDefaults(defineProps<Props>(), {
  readonly: false,
  canvasConfig: () => ({}),
  showWidgetTitles: false,
  multiDataSourceStore: () => ({}),
  multiDataSourceConfigStore: () => ({})
})

const emit = defineEmits(['node-select', 'request-settings'])

const message = useMessage()

// 组件状态
const fabricAvailable = ref(false)
const fabricContainer = ref<HTMLElement>()
const canvasContainer = ref<HTMLElement>()
const fabricRenderer = ref<FabricRenderer | null>(null)

// 从 graphData 中提取节点数据
const nodes = computed(() => props.graphData?.nodes || [])
const selectedNodes = computed(() => props.graphData?.selectedIds || [])

// 画布尺寸状态
const canvasSize = ref({ width: 1200, height: 800 })

/**
 * 检查 Fabric.js 依赖是否可用
 */
const checkFabricAvailability = async () => {
  try {
    // 动态导入 Fabric.js 进行检测
    const { Canvas } = await import('fabric')
    if (Canvas) {
      fabricAvailable.value = true
      console.log('✅ Fabric.js 6.7.1 依赖检测成功，但等待数据准备后再初始化')
    }
  } catch (error) {
    fabricAvailable.value = false
    console.warn('⚠️ Fabric.js 依赖未找到:', error)
  }
}

/**
 * 初始化 Fabric 渲染器
 */
const initFabricRenderer = async () => {
  console.log('🎯 开始初始化 Fabric 渲染器')
  console.log('🎯 canvasContainer.value:', canvasContainer.value)
  console.log('🎯 fabricRenderer.value:', fabricRenderer.value)

  if (!canvasContainer.value) {
    console.error('❌ Canvas 容器不存在')
    return
  }

  if (fabricRenderer.value) {
    console.log('⚠️ Fabric 渲染器已存在，跳过初始化')
    return
  }

  try {
    const config: FabricRendererConfig = {
      width: 1200,
      height: 800,
      backgroundColor: '#f8f9fa',
      selection: !props.readonly,
      interactive: !props.readonly,
      ...props.canvasConfig
    }

    fabricRenderer.value = new FabricRenderer(config)

    // 绑定事件
    fabricRenderer.value.onNodeSelect = handleNodeSelect
    fabricRenderer.value.onNodeMove = handleNodeMove
    fabricRenderer.value.onCanvasClick = handleCanvasClick
    fabricRenderer.value.onNodeContextMenu = handleNodeContextMenu

    // 初始化画布
    await fabricRenderer.value.init(canvasContainer.value)

    // 更新画布尺寸状态
    canvasSize.value = fabricRenderer.value.getSize()

    // 添加现有节点
    console.log('🎯 开始添加现有节点到 Fabric 画布, 节点数量:', nodes.value.length)
    for (const node of nodes.value) {
      console.log('📝 添加节点:', node.id, node.type, node)
      await fabricRenderer.value.addNode(node)
    }

    console.log('🎨 Fabric 渲染器组件初始化完成, 画布对象数量:', fabricRenderer.value.getNodes().size)

    // 🧪 添加测试节点来验证 Fabric 是否正常工作
    await addTestNodes()

  } catch (error) {
    console.error('❌ Fabric 渲染器初始化失败:', error)
    message.error(`Fabric 渲染器初始化失败: ${error}`)
  }
}

/**
 * 切换到简单渲染器
 */
const switchToSimpleRenderer = () => {
  message.info('请在渲染器选择中切换到简单渲染器')
}

/**
 * 处理节点选择
 */
const handleNodeSelect = (nodeId: string) => {
  console.log('🎯 Fabric 节点选择:', nodeId)
  emit('node-select', nodeId)
}

/**
 * 处理节点移动
 */
const handleNodeMove = (nodeId: string, x: number, y: number) => {
  console.log('🎯 Fabric 节点移动:', nodeId, { x, y })
  // TODO: 更新节点在 store 中的位置
}

/**
 * 处理画布点击
 */
const handleCanvasClick = (event: MouseEvent) => {
  console.log('🎯 Fabric 画布点击')
  emit('node-select', '') // 清空选择
}

/**
 * 处理右键菜单
 */
const handleNodeContextMenu = (nodeId: string, event: MouseEvent) => {
  console.log('🎯 Fabric 右键菜单:', nodeId)
  emit('request-settings', nodeId)
}

/**
 * 🧪 添加测试节点来验证 Fabric 是否正常工作
 */
const addTestNodes = async () => {
  if (!fabricRenderer.value) return

  try {
    console.log('🧪 开始添加测试节点')

    // 创建测试节点数据
    const testNodes = [
      {
        id: 'test-rect-1',
        type: 'rect',
        layout: { canvas: { x: 50, y: 50, width: 150, height: 100 } },
        properties: {}
      },
      {
        id: 'test-text-1',
        type: 'text',
        layout: { canvas: { x: 250, y: 80, width: 200, height: 50 } },
        properties: { text: '测试文本节点' }
      },
      {
        id: 'test-circle-1',
        type: 'circle',
        layout: { canvas: { x: 100, y: 200, width: 80, height: 80 } },
        properties: {}
      }
    ]

    for (const testNode of testNodes) {
      console.log('🧪 添加测试节点:', testNode.id, testNode.type)
      await fabricRenderer.value.addNode(testNode as any)
    }

    console.log('🧪 测试节点添加完成')

  } catch (error) {
    console.error('🧪 测试节点添加失败:', error)
  }
}

/**
 * 监听节点数据变化
 */
watch(
  () => [nodes.value, props.multiDataSourceStore, fabricAvailable.value],
  async ([newNodes, newDataStore, isFabricAvailable]) => {
    console.log('🔄 Fabric 数据监听触发:', {
      nodesCount: newNodes?.length || 0,
      dataSourcesCount: Object.keys(newDataStore || {}).length,
      fabricAvailable: isFabricAvailable,
      fabricRenderer: !!fabricRenderer.value
    })

    // 如果 Fabric 可用但渲染器未初始化，则初始化（不要求必须有节点数据）
    if (isFabricAvailable && !fabricRenderer.value) {
      console.log('🎯 Fabric 可用，开始初始化渲染器')
      await nextTick() // 确保 DOM 准备好
      await initFabricRenderer()
      return
    }

    // 如果渲染器已初始化，更新数据
    if (fabricRenderer.value) {
      console.log('🔄 更新 Fabric 画布数据')

      // 简单的重新渲染策略
      fabricRenderer.value.clear()

      if (newNodes && newNodes.length > 0) {
        console.log('🎯 重新添加节点到 Fabric 画布')
        for (const node of newNodes) {
          console.log('📝 重新添加节点:', node.id, node.type)
          await fabricRenderer.value.addNode(node)
        }
        console.log('✅ 节点重新添加完成, 画布对象数量:', fabricRenderer.value.getNodes().size)
      } else {
        console.log('⚠️ 没有节点数据需要添加')
      }
    } else {
      console.log('⚠️ Fabric 渲染器未初始化，等待条件满足')
    }
  },
  { deep: true, immediate: true }
)

/**
 * 监听只读模式变化
 */
watch(
  () => props.readonly,
  (newReadonly) => {
    if (fabricRenderer.value) {
      // TODO: 更新 Fabric 画布的交互模式
      console.log('🔄 Fabric 只读模式:', newReadonly)
    }
  }
)

// 生命周期
onMounted(async () => {
  console.log('🎯 FabricCanvasComponent onMounted')
  console.log('🎯 初始节点数据:', nodes.value)
  console.log('🎯 初始 graphData:', props.graphData)

  await checkFabricAvailability()

  // 如果 Fabric 可用，主动尝试初始化渲染器
  if (fabricAvailable.value) {
    console.log('🎯 组件挂载后主动初始化 Fabric 渲染器')
    await nextTick() // 确保 DOM 完全准备好
    setTimeout(async () => {
      // 延迟一点初始化，确保容器已渲染
      if (!fabricRenderer.value) {
        await initFabricRenderer()
      }
    }, 100)
  }
})

onUnmounted(() => {
  if (fabricRenderer.value) {
    fabricRenderer.value.destroy()
    fabricRenderer.value = null
  }
})
</script>

<style scoped>
/* Fabric Canvas 容器样式 */
.fabric-canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 600px;
  background: var(--n-color);
  border-radius: var(--n-border-radius);
}

/* Fabric 依赖缺失容器 */
.fabric-missing-container {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 600px;
  background: var(--n-color);
  border-radius: var(--n-border-radius);
}

/* Fabric Canvas 包装器 */
.fabric-canvas-wrapper {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

/* 信息栏样式 */
.fabric-info-bar {
  padding: 12px 16px;
  background: var(--n-card-color);
  border-radius: var(--n-border-radius);
  margin: 16px 16px 0 16px;
  border: 1px solid var(--n-border-color);
  flex-shrink: 0;
}

/* Fabric 画布区域 */
.fabric-canvas-area {
  flex: 1;
  padding: 16px;
  overflow: auto;
}

/* 画布样式 */
.fabric-canvas-area :deep(#fabric-canvas) {
  border: 1px solid var(--n-border-color);
  border-radius: var(--n-border-radius);
  box-shadow: var(--n-box-shadow-1);
}

/* 响应式布局 */
@media (max-width: 768px) {
  .fabric-info-bar {
    margin: 12px;
    padding: 8px 12px;
  }

  .fabric-canvas-area {
    padding: 12px;
  }
}
</style>