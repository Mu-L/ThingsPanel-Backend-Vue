<script setup lang="ts">
import { ref, reactive, computed, onMounted, onUnmounted, watch } from 'vue'
import type { CanvasItem, CanvasConfig, CanvasRendererProps } from './types'
import type { BaseRendererProps, RendererEvents } from '../base/interfaces'
import { CanvasRenderer } from './CanvasRenderer'
import { CanvasAdapter, type ExternalPanelData } from '../adapters/CanvasAdapter'
import { mockCanvasData as mockExternalData } from '../adapters/mockData'

// Props definition
interface Props extends Omit<BaseRendererProps, 'items'> {
  /** Canvas项目列表 */
  items?: CanvasItem[]
  /** 外部面板数据 - 优先级高于items */
  externalData?: ExternalPanelData
  /** Canvas配置 */
  canvasConfig?: Partial<CanvasConfig>
}

const props = withDefaults(defineProps<Props>(), {
  items: () => [],
  selectedIds: () => [],
  editable: true,
  showGrid: true,
  canvasConfig: () => ({}),
  externalData: undefined
})

// Events
const emit = defineEmits<RendererEvents>()

// Default Canvas configuration
const defaultCanvasConfig: CanvasConfig = {
  width: 1200,
  height: 800,
  zoom: 1,
  minZoom: 0.1,
  maxZoom: 5,
  backgroundColor: '#ffffff',
  grid: {
    enabled: true,
    size: 20,
    snap: true,
    color: '#e5e7eb',
    opacity: 0.5,
    visible: true
  },
  selectionBox: true,
  multiSelect: true,
  drag: {
    enabled: true,
    threshold: 5,
    containment: true
  },
  resize: {
    enabled: true,
    handleSize: 8,
    aspectRatio: false
  }
}

// Reactive state
const canvasContainer = ref<HTMLElement>()
const rendererInstance = ref<CanvasRenderer | null>(null)
const isRendererLoaded = ref(false)
const rendererError = ref<string | null>(null)

// 测试数据控制
const useTestData = ref(false)

// 切换测试数据
const toggleTestData = () => {
  useTestData.value = !useTestData.value
  console.log('Canvas渲染器: 切换测试数据模式', useTestData.value ? '启用' : '禁用')
}

// 画布配置 - 根据测试数据或外部数据调整
const dynamicCanvasConfig = computed(() => {
  const baseConfig = { ...defaultCanvasConfig, ...props.canvasConfig }
  
  // 确定要使用的数据源
  const dataSource = useTestData.value ? mockExternalData : props.externalData
  
  // 如果有数据源，使用其布局配置
  if (dataSource?.layout) {
    const layout = dataSource.layout
    return {
      ...baseConfig,
      width: layout.width || baseConfig.width,
      height: layout.height || baseConfig.height,
      backgroundColor: layout.backgroundColor || baseConfig.backgroundColor,
      grid: {
        ...baseConfig.grid,
        size: layout.gridSize || baseConfig.grid.size,
        visible: layout.showGrid !== false
      }
    }
  }
  
  return baseConfig
})

// 当前Canvas配置
const canvasConfig = computed(() => {
  return rendererInstance.value?.getConfig() || dynamicCanvasConfig.value
})

// Computed properties
const isEditMode = computed(() => props.mode === 'edit')

// 数据处理 - 优先使用测试数据，然后是外部数据，最后是直接传入的items
const canvasItems = computed(() => {
  // 如果启用测试数据，使用模拟数据
  if (useTestData.value) {
    try {
      const convertedItems = CanvasAdapter.convertPanelToCanvasItems(mockExternalData)
      console.log('Canvas渲染器: 测试数据转换完成', {
        原始数据: mockExternalData,
        转换后项目数: convertedItems.length
      })
      return convertedItems
    } catch (error) {
      console.error('Canvas渲染器: 测试数据转换失败', error)
      return props.items || []
    }
  }
  
  // 如果有外部数据，使用适配器转换
  if (props.externalData) {
    try {
      const convertedItems = CanvasAdapter.convertPanelToCanvasItems(props.externalData)
      console.log('Canvas渲染器: 外部数据转换完成', {
        原始数据: props.externalData,
        转换后项目数: convertedItems.length
      })
      return convertedItems
    } catch (error) {
      console.error('Canvas渲染器: 外部数据转换失败', error)
      return props.items || []
    }
  }
  
  // 否则使用直接传入的items
  return props.items || []
})

// 数据验证状态
const dataValidation = computed(() => {
  const dataToValidate = useTestData.value ? mockExternalData : props.externalData
  if (!dataToValidate) return null
  return CanvasAdapter.validateExternalData(dataToValidate)
})

// 数据统计信息
const dataStatistics = computed(() => {
  const dataToAnalyze = useTestData.value ? mockExternalData : props.externalData
  if (!dataToAnalyze) return null
  return CanvasAdapter.getDataStatistics(dataToAnalyze)
})



// Canvas state
const canvasState = computed(() => {
  return rendererInstance.value?.getState() || {
    initialized: false,
    viewport: { x: 0, y: 0, zoom: 1 },
    selectedCount: 0,
    totalItems: 0
  }
})

// Methods
const initializeRenderer = async () => {
  if (!canvasContainer.value) {
    console.error('Canvas容器未找到')
    return
  }

  try {
    isRendererLoaded.value = false
    rendererError.value = null

    // 创建CanvasRenderer实例
    rendererInstance.value = new CanvasRenderer(canvasContainer.value, dynamicCanvasConfig.value)

    // 设置事件监听器
    rendererInstance.value.on('item-change', handleItemChange)
    rendererInstance.value.on('item-select', handleItemSelect)
    rendererInstance.value.on('item-click', handleItemClick)
    rendererInstance.value.on('item-dblclick', handleItemDoubleClick)
    rendererInstance.value.on('item-contextmenu', handleItemContextMenu)
    rendererInstance.value.on('zoom-change', handleZoomChange)

    // 初始化渲染器
    await rendererInstance.value.init()

    // 加载初始数据
    if (canvasItems.value.length > 0) {
      for (const item of canvasItems.value) {
        rendererInstance.value.addItem(item)
      }
    }

    isRendererLoaded.value = true
    console.log('Canvas渲染器初始化完成')
  } catch (error) {
    console.error('Canvas渲染器初始化失败:', error)
    rendererError.value = error instanceof Error ? error.message : '未知错误'
  }
}

const destroyRenderer = () => {
  if (rendererInstance.value) {
    rendererInstance.value.destroy()
    rendererInstance.value = null
  }
  isRendererLoaded.value = false
  rendererError.value = null
}

// 事件处理函数
const handleItemChange = (item: CanvasItem) => {
  emit('item-update', item.id, {
    position: item.position,
    size: item.size
  })
}

const handleItemSelect = (item: CanvasItem) => {
  emit('item-select', [item.id])
}

const handleItemClick = (item: CanvasItem) => {
  console.log('Canvas项目点击:', item)
}

const handleItemDoubleClick = (item: CanvasItem) => {
  console.log('Canvas项目双击:', item)
}

const handleItemContextMenu = (item: CanvasItem, position: { x: number; y: number }) => {
  console.log('Canvas项目右键:', item, position)
}

const handleItemRemove = (item: CanvasItem) => {
  emit('item-remove', item.id)
}

const handleZoomChange = (zoom: number) => {
  console.log('Canvas缩放变化:', zoom)
}

// 监听器
watch(
  () => canvasItems.value,
  (newItems) => {
    if (rendererInstance.value && isRendererLoaded.value) {
      // 清空现有项目
      rendererInstance.value.clearAll()
      // 添加新项目
      for (const item of newItems) {
        rendererInstance.value.addItem(item)
      }
    }
  },
  { deep: true }
)

watch(
  () => props.mode,
  (newMode) => {
    if (rendererInstance.value) {
      rendererInstance.value.setMode(newMode)
    }
  }
)

// Lifecycle
onMounted(() => {
  initializeRenderer()
})

onUnmounted(() => {
  destroyRenderer()
})
</script>

<template>
  <div class="canvas-renderer h-full w-full">
    <!-- 错误状态显示 -->
    <div v-if="rendererError" class="error-panel">
      <div class="error-title">Canvas渲染器错误</div>
      <div class="error-message">{{ rendererError }}</div>
    </div>

    <!-- Canvas容器 -->
    <div 
      ref="canvasContainer"
      class="canvas-container"
      :class="{
        'edit-mode': mode === 'edit',
        'view-mode': mode === 'view',
        'loading': !isRendererLoaded
      }"
    >
      <!-- 加载状态 -->
      <div v-if="!isRendererLoaded" class="loading-overlay">
        <div class="loading-spinner"></div>
        <p class="text-sm text-gray-500 mt-2">正在初始化Canvas渲染器...</p>
      </div>
    </div>

    <!-- 底部状态栏 -->
    <div class="status-bar bg-gray-50 dark:bg-gray-800 p-3 border-t border-gray-200 dark:border-gray-600">
      <div class="flex items-center justify-between text-xs text-gray-600 dark:text-gray-400">
        <div class="flex items-center space-x-4">
          <div class="flex items-center space-x-1">
            <div class="w-2 h-2 rounded-full" :class="{
              'bg-green-500': isRendererLoaded,
              'bg-red-500': !isRendererLoaded
            }"></div>
            <span>渲染器: {{ isRendererLoaded ? '已加载' : '未加载' }}</span>
          </div>
          
          <div>模式: {{ mode === 'edit' ? '编辑' : '查看' }}</div>
          <div>项目数: {{ rendererInstance?.getItemCount() || 0 }}</div>
          <div>选中数: {{ rendererInstance?.getSelectedCount() || 0 }}</div>
          <div v-if="canvasState.viewport">缩放: {{ Math.round(canvasState.viewport.zoom * 100) }}%</div>
        </div>
        
        <div class="flex items-center space-x-2">
          <span>Canvas v{{ rendererInstance?.version || '1.0.0' }}</span>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.canvas-renderer {
  @apply h-full flex flex-col;
}

.canvas-container {
  @apply w-full h-full relative;
}

.canvas-container.edit-mode {
  @apply cursor-crosshair;
}

.canvas-container.view-mode {
  @apply cursor-default;
}

.canvas-container.loading {
  @apply opacity-50;
}

/* 加载状态样式 */
.loading-overlay {
  @apply absolute inset-0 flex flex-col items-center justify-center bg-white dark:bg-gray-900 bg-opacity-75 z-10;
}

.loading-spinner {
  @apply w-8 h-8 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin;
}

/* 错误状态样式 */
.error-panel {
  @apply bg-red-50 dark:bg-red-900 border border-red-200 dark:border-red-700 rounded-lg p-4;
}

.error-panel .error-title {
  @apply text-red-800 dark:text-red-200 font-medium mb-2;
}

.error-panel .error-message {
  @apply text-red-600 dark:text-red-400 text-sm;
}

/* 状态栏样式 */
.status-bar {
  @apply flex-shrink-0;
}

/* 响应式样式 */
@media (max-width: 768px) {
  .canvas-container {
    @apply px-2;
  }
}
</style>