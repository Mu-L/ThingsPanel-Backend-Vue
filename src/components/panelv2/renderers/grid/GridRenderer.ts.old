// 轻量级网格渲染器实现
// Lightweight grid renderer implementation

import { BaseRenderer } from '../base/BaseRenderer'
import type { BaseItem, RenderMode, ItemUpdateData } from '../base/types'
import type { GridConfig, GridItem, DragState, ResizeState, GridRendererState } from './types'

/** 轻量级网格渲染器 */
export class GridRenderer extends BaseRenderer {
  readonly name = 'Grid Renderer'
  readonly version = '1.0.0'
  readonly description = 'Lightweight grid-based layout renderer with drag & drop support'

  // 渲染器状态
  private container: HTMLElement | null = null
  private gridContainer: HTMLElement | null = null
  private config: GridConfig
  private dragState: DragState = { isDragging: false }
  private resizeState: ResizeState = { isResizing: false }
  private scale = 1

  // 防抖DOM更新，避免与Vue冲突
  private updateThrottleId: number | null = null

  // 默认配置
  private static readonly DEFAULT_CONFIG: GridConfig = {
    columns: 12,
    rowHeight: 60,
    gap: 8,
    showGrid: true,
    enableSnap: true,
    snapThreshold: 10,
    minItemWidth: 100,
    minItemHeight: 60,
    padding: 16
  }

  constructor(container?: HTMLElement, config?: Partial<GridConfig>) {
    super()
    this.config = { ...GridRenderer.DEFAULT_CONFIG, ...config }
    if (container) {
      this.container = container
    }
  }

  // 初始化渲染器
  init(): void {
    if (this.initialized) {
      console.warn('GridRenderer is already initialized')
      return
    }

    if (!this.container) {
      throw new Error('Container element is required for GridRenderer')
    }

    this.setupContainer()
    this.setupEventListeners()
    this.renderGrid()
    this.initialized = true

    console.log('GridRenderer initialized successfully')
  }

  // 销毁渲染器
  destroy(): void {
    if (!this.initialized) return

    // 清理防抖更新
    if (this.updateThrottleId !== null) {
      cancelAnimationFrame(this.updateThrottleId)
      this.updateThrottleId = null
    }

    this.removeEventListeners()
    this.clearContainer()
    this.items.clear()
    this.selectedIds.clear()
    this.initialized = false

    console.log('GridRenderer destroyed')
  }

  // 刷新渲染
  refresh(): void {
    if (!this.initialized) return

    this.renderGrid()
    this.renderAllItems()
  }

  // 渲染单个项目
  protected renderItem(item: BaseItem): void {
    if (!this.gridContainer) return

    const gridItem = this.convertToGridItem(item)
    const element = this.createItemElement(gridItem)
    this.gridContainer.appendChild(element)
    this.updateItemPosition(element, gridItem)
  }

  // 从DOM中移除项目
  protected removeItemFromDOM(id: string): void {
    if (!this.gridContainer) return

    const element = this.gridContainer.querySelector(`[data-item-id="${id}"]`)
    if (element) {
      element.remove()
    }
  }

  // 设置容器
  private setupContainer(): void {
    if (!this.container) return

    // ⚠️ 关键修复：不要清空Vue管理的容器，避免与Vue DOM更新冲突
    // this.container.innerHTML = '' // 这行代码导致了insertBefore错误！

    // 设置容器样式
    this.container.style.position = 'relative'
    this.container.style.width = '100%'
    this.container.style.height = '100%'
    this.container.style.overflow = 'auto'
    // 移除padding，让子容器处理

    // 查找或创建网格内容容器（避免与Vue内容冲突）
    let existingGridContainer = this.container.querySelector('.renderer-grid-content') as HTMLElement
    if (existingGridContainer) {
      // 如果存在，清空内容但保留容器
      existingGridContainer.innerHTML = ''
      this.gridContainer = existingGridContainer
    } else {
      // 创建新的网格内容容器
      this.gridContainer = document.createElement('div')
      this.gridContainer.className = 'renderer-grid-content'
      this.container.appendChild(this.gridContainer)
    }
    
    // 设置网格容器样式
    this.gridContainer.style.position = 'absolute'
    this.gridContainer.style.top = '0'
    this.gridContainer.style.left = '0'
    this.gridContainer.style.right = '0'
    this.gridContainer.style.bottom = '0'
    this.gridContainer.style.padding = `${this.config.padding}px`
    this.gridContainer.style.minHeight = '100%'
    this.gridContainer.style.background = this.config.showGrid ? this.generateGridBackground() : 'transparent'
    this.gridContainer.style.zIndex = '1' // 确保在Vue内容之上
  }

  // 清空容器
  private clearContainer(): void {
    // ⚠️ 不要清空Vue管理的容器，只清空我们的网格内容
    if (this.gridContainer) {
      this.gridContainer.innerHTML = ''
      // 移除我们创建的网格容器，但保留Vue管理的内容
      if (this.gridContainer.parentNode === this.container) {
        this.container.removeChild(this.gridContainer)
      }
    }
    this.gridContainer = null
  }

  // 生成网格背景
  private generateGridBackground(): string {
    const { columns, rowHeight, gap } = this.config
    const columnWidth = `calc((100% - ${(columns - 1) * gap}px) / ${columns})`

    return `
      linear-gradient(to right, #e0e0e0 1px, transparent 1px),
      linear-gradient(to bottom, #e0e0e0 1px, transparent 1px)
    `
  }

  // 渲染网格
  private renderGrid(): void {
    if (!this.gridContainer) return

    if (this.config.showGrid) {
      this.gridContainer.style.background = this.generateGridBackground()
      this.gridContainer.style.backgroundSize = `calc(100% / ${this.config.columns}) ${this.config.rowHeight + this.config.gap}px`
    } else {
      this.gridContainer.style.background = 'transparent'
    }
  }

  // 渲染所有项目
  private renderAllItems(): void {
    if (!this.gridContainer) return

    // 清空现有项目
    this.gridContainer.innerHTML = ''

    // 渲染所有项目
    this.items.forEach(item => {
      this.renderItem(item)
    })
  }

  // 转换为网格项目
  private convertToGridItem(item: BaseItem): GridItem {
    // 如果已经是网格项目，直接返回
    if ('gridPosition' in item) {
      return item as GridItem
    }

    // 转换像素位置为网格位置
    const gridPosition = this.pixelToGrid(item.position, item.size)

    return {
      ...item,
      gridPosition
    }
  }

  // 像素位置转网格位置
  private pixelToGrid(position: { x: number; y: number }, size: { width: number; height: number }) {
    const { columns, rowHeight, gap } = this.config
    const columnWidth = (this.gridContainer!.clientWidth - (columns - 1) * gap) / columns

    const col = Math.round(position.x / (columnWidth + gap))
    const row = Math.round(position.y / (rowHeight + gap))
    const colSpan = Math.max(1, Math.round(size.width / (columnWidth + gap)))
    const rowSpan = Math.max(1, Math.round(size.height / (rowHeight + gap)))

    return {
      col: Math.max(0, Math.min(col, columns - colSpan)),
      row: Math.max(0, row),
      colSpan: Math.min(colSpan, columns - col),
      rowSpan
    }
  }

  // 网格位置转像素位置
  private gridToPixel(gridPosition: { col: number; row: number; colSpan: number; rowSpan: number }) {
    const { columns, rowHeight, gap } = this.config
    const columnWidth = (this.gridContainer!.clientWidth - (columns - 1) * gap) / columns

    return {
      position: {
        x: gridPosition.col * (columnWidth + gap),
        y: gridPosition.row * (rowHeight + gap)
      },
      size: {
        width: gridPosition.colSpan * columnWidth + (gridPosition.colSpan - 1) * gap,
        height: gridPosition.rowSpan * rowHeight + (gridPosition.rowSpan - 1) * gap
      }
    }
  }

  // 创建项目元素
  private createItemElement(item: GridItem): HTMLElement {
    const element = document.createElement('div')
    element.className = 'grid-item'
    element.setAttribute('data-item-id', item.id)
    element.setAttribute('data-item-type', item.type)

    // 基础样式
    element.style.position = 'absolute'
    element.style.border = '1px solid #ddd'
    element.style.borderRadius = '4px'
    element.style.background = '#fff'
    element.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)'
    element.style.cursor = this.mode === 'edit' ? 'move' : 'default'
    element.style.userSelect = 'none'
    element.style.overflow = 'hidden'

    // 选中状态
    if (this.selectedIds.has(item.id)) {
      element.style.borderColor = '#1890ff'
      element.style.boxShadow = '0 0 0 2px rgba(24,144,255,0.2)'
    }

    // 内容
    element.innerHTML = `
      <div style="padding: 8px; height: 100%; display: flex; flex-direction: column;">
        <div style="font-weight: bold; margin-bottom: 4px;">${item.title || item.type}</div>
        <div style="flex: 1; font-size: 12px; color: #666;">${item.id}</div>
      </div>
    `

    // 编辑模式下添加调整大小句柄
    if (this.mode === 'edit') {
      this.addResizeHandles(element)
    }

    return element
  }

  // 添加调整大小句柄
  private addResizeHandles(element: HTMLElement): void {
    // 检查是否已经有句柄，避免重复添加
    if (element.querySelector('.resize-handle')) {
      return
    }

    const handles = ['se'] // 只添加右下角句柄

    handles.forEach(direction => {
      // 使用requestAnimationFrame确保DOM操作安全
      requestAnimationFrame(() => {
        if (!document.contains(element)) {
          return // 元素已被移除
        }

        const handle = document.createElement('div')
        handle.className = `resize-handle resize-${direction}`
        handle.style.position = 'absolute'
        handle.style.width = '10px'
        handle.style.height = '10px'
        handle.style.background = '#1890ff'
        handle.style.cursor = `${direction}-resize`
        handle.style.zIndex = '10' // 确保句柄在最上层

        // 位置设置
        if (direction === 'se') {
          handle.style.right = '-5px'
          handle.style.bottom = '-5px'
        }

        // 安全的DOM追加
        try {
          element.appendChild(handle)
        } catch (error) {
          console.warn('Failed to append resize handle:', error)
        }
      })
    })
  }

  // 更新项目位置
  private updateItemPosition(element: HTMLElement, item: GridItem): void {
    const { position, size } = this.gridToPixel(item.gridPosition)

    element.style.left = `${position.x}px`
    element.style.top = `${position.y}px`
    element.style.width = `${size.width}px`
    element.style.height = `${size.height}px`
  }

  // 设置事件监听器
  private setupEventListeners(): void {
    if (!this.gridContainer) return

    // 鼠标事件
    this.gridContainer.addEventListener('mousedown', this.handleMouseDown.bind(this))
    document.addEventListener('mousemove', this.handleMouseMove.bind(this))
    document.addEventListener('mouseup', this.handleMouseUp.bind(this))

    // 点击事件
    this.gridContainer.addEventListener('click', this.handleClick.bind(this))
  }

  // 移除事件监听器
  private removeEventListeners(): void {
    document.removeEventListener('mousemove', this.handleMouseMove.bind(this))
    document.removeEventListener('mouseup', this.handleMouseUp.bind(this))
  }

  // 鼠标按下事件
  private handleMouseDown(event: MouseEvent): void {
    if (this.mode !== 'edit') return

    const target = event.target as HTMLElement
    const itemElement = target.closest('.grid-item') as HTMLElement

    if (!itemElement) return

    const itemId = itemElement.getAttribute('data-item-id')
    if (!itemId) return

    event.preventDefault()

    // 检查是否点击了调整大小句柄
    if (target.classList.contains('resize-handle')) {
      this.startResize(itemId, target.className, event)
    } else {
      this.startDrag(itemId, event)
    }
  }

  // 开始拖拽
  private startDrag(itemId: string, event: MouseEvent): void {
    const item = this.items.get(itemId)
    if (!item) return

    this.dragState = {
      isDragging: true,
      dragItemId: itemId,
      startPosition: { x: event.clientX, y: event.clientY },
      currentPosition: { x: event.clientX, y: event.clientY },
      offset: {
        x: event.offsetX,
        y: event.offsetY
      }
    }

    // 选中项目
    this.selectItems([itemId])

    this.emit('drag-start', itemId, { x: event.clientX, y: event.clientY })
  }

  // 开始调整大小
  private startResize(itemId: string, handleClass: string, event: MouseEvent): void {
    const item = this.items.get(itemId)
    if (!item) return

    const direction = handleClass
      .split(' ')
      .find(cls => cls.startsWith('resize-'))
      ?.replace('resize-', '') as any

    this.resizeState = {
      isResizing: true,
      resizeItemId: itemId,
      direction,
      startSize: { ...item.size },
      startPosition: { x: event.clientX, y: event.clientY }
    }
  }

  // 鼠标移动事件
  private handleMouseMove(event: MouseEvent): void {
    if (this.dragState.isDragging) {
      this.handleDragMove(event)
    } else if (this.resizeState.isResizing) {
      this.handleResizeMove(event)
    }
  }

  // 处理拖拽移动
  private handleDragMove(event: MouseEvent): void {
    if (!this.dragState.dragItemId || !this.gridContainer) return

    // 安全的DOM查询，确保容器和元素都存在
    if (!document.contains(this.gridContainer)) {
      console.warn('Grid container was removed from DOM during drag')
      this.dragState = { isDragging: false }
      return
    }

    const element = this.gridContainer.querySelector(`[data-item-id="${this.dragState.dragItemId}"]`) as HTMLElement
    if (!element || !document.contains(element)) {
      console.warn('Drag element was removed from DOM during drag')
      this.dragState = { isDragging: false }
      return
    }

    // 计算新位置
    const deltaX = event.clientX - this.dragState.startPosition!.x
    const deltaY = event.clientY - this.dragState.startPosition!.y

    const item = this.items.get(this.dragState.dragItemId)!
    const gridItem = this.convertToGridItem(item)
    const { position } = this.gridToPixel(gridItem.gridPosition)

    const newPosition = {
      x: Math.max(0, position.x + deltaX),
      y: Math.max(0, position.y + deltaY)
    }

    // 磁吸到网格
    if (this.config.enableSnap) {
      const snappedGrid = this.pixelToGrid(newPosition, item.size)
      const snappedPixel = this.gridToPixel(snappedGrid)

      if (Math.abs(newPosition.x - snappedPixel.position.x) < this.config.snapThreshold) {
        newPosition.x = snappedPixel.position.x
      }
      if (Math.abs(newPosition.y - snappedPixel.position.y) < this.config.snapThreshold) {
        newPosition.y = snappedPixel.position.y
      }
    }

    // 防抖DOM更新：避免频繁的DOM操作与Vue冲突
    this.throttledDOMUpdate(() => {
      if (element && document.contains(element)) {
        element.style.left = `${newPosition.x}px`
        element.style.top = `${newPosition.y}px`
      }
    })

    this.dragState.currentPosition = { x: event.clientX, y: event.clientY }
  }

  // 处理调整大小移动
  private handleResizeMove(event: MouseEvent): void {
    if (!this.resizeState.resizeItemId || !this.gridContainer) return

    // 安全的DOM查询，确保容器和元素都存在
    if (!document.contains(this.gridContainer)) {
      console.warn('Grid container was removed from DOM during resize')
      this.resizeState = { isResizing: false }
      return
    }

    const element = this.gridContainer.querySelector(`[data-item-id="${this.resizeState.resizeItemId}"]`) as HTMLElement
    if (!element || !document.contains(element)) {
      console.warn('Resize element was removed from DOM during resize')
      this.resizeState = { isResizing: false }
      return
    }

    const deltaX = event.clientX - this.resizeState.startPosition!.x
    const deltaY = event.clientY - this.resizeState.startPosition!.y

    const newSize = {
      width: Math.max(this.config.minItemWidth, this.resizeState.startSize!.width + deltaX),
      height: Math.max(this.config.minItemHeight, this.resizeState.startSize!.height + deltaY)
    }

    // 防抖DOM更新：避免频繁的DOM操作与Vue冲突
    this.throttledDOMUpdate(() => {
      if (element && document.contains(element)) {
        element.style.width = `${newSize.width}px`
        element.style.height = `${newSize.height}px`
      }
    })

    this.resizeState.currentSize = newSize
  }

  // 鼠标抬起事件
  private handleMouseUp(event: MouseEvent): void {
    if (this.dragState.isDragging) {
      this.endDrag(event)
    } else if (this.resizeState.isResizing) {
      this.endResize(event)
    }
  }

  // 结束拖拽
  private endDrag(event: MouseEvent): void {
    if (!this.dragState.dragItemId || !this.gridContainer) return

    const item = this.items.get(this.dragState.dragItemId)
    if (!item) {
      this.dragState = { isDragging: false }
      return
    }

    // 安全的DOM查询
    if (!document.contains(this.gridContainer)) {
      console.warn('Grid container was removed during drag end')
      this.dragState = { isDragging: false }
      return
    }

    const element = this.gridContainer.querySelector(`[data-item-id="${this.dragState.dragItemId}"]`) as HTMLElement
    if (!element || !document.contains(element)) {
      console.warn('Drag element was removed during drag end')
      this.dragState = { isDragging: false }
      return
    }

    // 计算最终位置
    const rect = element.getBoundingClientRect()
    const containerRect = this.gridContainer.getBoundingClientRect()

    const newPosition = {
      x: rect.left - containerRect.left,
      y: rect.top - containerRect.top
    }

    // 转换为网格位置并更新项目
    const gridPosition = this.pixelToGrid(newPosition, item.size)
    const updates: ItemUpdateData = {
      position: newPosition
    }

    // 如果是网格项目，更新网格位置
    if ('gridPosition' in item) {
      ;(updates as any).gridPosition = gridPosition
    }

    this.updateItem(this.dragState.dragItemId, updates)

    this.emit('drag-end', this.dragState.dragItemId, newPosition)

    // 重置拖拽状态
    this.dragState = { isDragging: false }
  }

  // 结束调整大小
  private endResize(event: MouseEvent): void {
    if (!this.resizeState.resizeItemId || !this.resizeState.currentSize) return

    const updates: ItemUpdateData = {
      size: this.resizeState.currentSize
    }

    this.updateItem(this.resizeState.resizeItemId, updates)

    // 重置调整大小状态
    this.resizeState = { isResizing: false }
  }

  // 点击事件
  private handleClick(event: MouseEvent): void {
    const target = event.target as HTMLElement
    const itemElement = target.closest('.grid-item') as HTMLElement

    if (itemElement) {
      const itemId = itemElement.getAttribute('data-item-id')
      if (itemId) {
        // 切换选择状态
        if (event.ctrlKey || event.metaKey) {
          const newSelection = this.selectedIds.has(itemId)
            ? Array.from(this.selectedIds).filter(id => id !== itemId)
            : [...Array.from(this.selectedIds), itemId]
          this.selectItems(newSelection)
        } else {
          this.selectItems([itemId])
        }
      }
    } else {
      // 点击空白区域，清空选择
      this.clearSelection()
    }
  }

  // 重写选择方法以更新视觉状态
  selectItems(ids: string[]): void {
    super.selectItems(ids)
    this.updateSelectionVisual()
  }

  clearSelection(): void {
    super.clearSelection()
    this.updateSelectionVisual()
  }

  // 更新选择视觉状态
  private updateSelectionVisual(): void {
    if (!this.gridContainer) return

    const allItems = this.gridContainer.querySelectorAll('.grid-item')
    allItems.forEach(element => {
      const itemId = element.getAttribute('data-item-id')
      if (itemId && this.selectedIds.has(itemId)) {
        ;(element as HTMLElement).style.borderColor = '#1890ff'
        ;(element as HTMLElement).style.boxShadow = '0 0 0 2px rgba(24,144,255,0.2)'
      } else {
        ;(element as HTMLElement).style.borderColor = '#ddd'
        ;(element as HTMLElement).style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)'
      }
    })
  }

  // 获取配置
  getConfig(): GridConfig {
    return { ...this.config }
  }

  // 更新配置
  updateConfig(newConfig: Partial<GridConfig>): void {
    this.config = { ...this.config, ...newConfig }
    this.refresh()
  }

  // 获取状态
  getState(): GridRendererState {
    return {
      config: this.getConfig(),
      dragState: { ...this.dragState },
      resizeState: { ...this.resizeState },
      showGrid: this.config.showGrid,
      scale: this.scale
    }
  }

  // 防抖DOM更新方法
  private throttledDOMUpdate(callback: () => void): void {
    if (this.updateThrottleId !== null) {
      cancelAnimationFrame(this.updateThrottleId)
    }
    
    this.updateThrottleId = requestAnimationFrame(() => {
      callback()
      this.updateThrottleId = null
    })
  }

  // 设置容器
  setContainer(container: HTMLElement): void {
    if (this.initialized) {
      this.destroy()
    }
    this.container = container
    if (container) {
      this.init()
    }
  }
}
