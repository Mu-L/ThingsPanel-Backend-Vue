<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>架构修复验证测试</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; margin-top: 30px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background: #fafafa; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        .info { background: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; }
        button { background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #2980b9; }
        .status { font-weight: bold; display: inline-block; width: 100px; }
        .json-display { background: #f4f4f4; border: 1px solid #ddd; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; }
        .property-path { background: #e8f4fd; border-left: 4px solid #3498db; padding: 10px; margin: 10px 0; font-family: monospace; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔧 架构修复验证测试</h1>
        <p>本页面验证所有关键架构修复是否正确实现，包括配置迁移、数据源触发机制、属性暴露和路径管理。</p>

        <div class="test-section">
            <h2>1️⃣ 配置迁移验证</h2>
            <p>验证组件级设备配置是否正确迁移到基础配置</p>
            <button onclick="testConfigurationMigration()">测试配置迁移</button>
            <div id="config-migration-result"></div>
        </div>

        <div class="test-section">
            <h2>2️⃣ 数据源触发机制验证</h2>
            <p>验证属性变化是否通过配置更新触发执行器（不再直接刷新）</p>
            <button onclick="testDataSourceTrigger()">测试数据源触发</button>
            <div id="datasource-trigger-result"></div>
        </div>

        <div class="test-section">
            <h2>3️⃣ 属性暴露验证</h2>
            <p>验证基础配置属性（deviceId、metricsList）是否在属性绑定界面可见</p>
            <button onclick="testPropertyExposure()">测试属性暴露</button>
            <div id="property-exposure-result"></div>
        </div>

        <div class="test-section">
            <h2>4️⃣ 属性路径格式验证</h2>
            <p>验证属性路径是否使用正确的格式：componentId.configSection.propertyPath</p>
            <button onclick="testPropertyPathFormat()">测试属性路径格式</button>
            <div id="property-path-result"></div>
        </div>

        <div class="test-section">
            <h2>5️⃣ 端到端集成测试</h2>
            <p>模拟完整的属性变化 → 配置更新 → 执行器触发流程</p>
            <button onclick="testEndToEndFlow()">测试端到端流程</button>
            <div id="e2e-test-result"></div>
        </div>

        <div class="test-section">
            <h2>📊 总体验证状态</h2>
            <div id="overall-status">
                <div class="info">点击上方按钮开始测试...</div>
            </div>
        </div>
    </div>

    <script type="module">
        let testResults = {
            configMigration: null,
            dataSourceTrigger: null,
            propertyExposure: null,
            propertyPath: null,
            endToEnd: null
        };

        // 更新总体状态
        function updateOverallStatus() {
            const results = Object.values(testResults);
            const completed = results.filter(r => r !== null).length;
            const passed = results.filter(r => r === true).length;
            const failed = results.filter(r => r === false).length;

            const statusDiv = document.getElementById('overall-status');
            
            if (completed === 0) {
                statusDiv.innerHTML = '<div class="info">点击上方按钮开始测试...</div>';
                return;
            }

            let statusClass = 'info';
            let statusText = `测试进度：${completed}/5`;
            
            if (completed === 5) {
                if (failed === 0) {
                    statusClass = 'success';
                    statusText = `🎉 所有测试通过！ (${passed}/${completed})`;
                } else {
                    statusClass = 'error';
                    statusText = `⚠️ 测试完成，有 ${failed} 个失败 (通过:${passed}, 失败:${failed})`;
                }
            } else {
                statusText += ` (通过:${passed}, 失败:${failed})`;
            }

            statusDiv.innerHTML = `<div class="${statusClass}">${statusText}</div>`;
        }

        // 显示测试结果的辅助函数
        function displayResult(containerId, success, title, details, data = null) {
            const container = document.getElementById(containerId);
            const resultClass = success ? 'success' : 'error';
            const icon = success ? '✅' : '❌';
            
            let html = `
                <div class="${resultClass}">
                    ${icon} ${title}
                    ${details}
                </div>
            `;
            
            if (data) {
                html += `<div class="json-display">${JSON.stringify(data, null, 2)}</div>`;
            }
            
            container.innerHTML = html;
        }

        // 1. 测试配置迁移
        window.testConfigurationMigration = async function() {
            try {
                // 动态导入必要模块
                const { configurationIntegrationBridge } = await import('./src/components/visual-editor/configuration/ConfigurationIntegrationBridge.js');
                
                console.log('🧪 [ArchitectureFixes] 开始配置迁移测试');

                // 创建一个模拟的旧格式配置
                const testComponentId = 'test-migration-' + Date.now();
                const oldFormatConfig = {
                    base: {},
                    component: {
                        deviceId: 'test-device-123',
                        metricsList: [
                            { id: 'temp', name: '温度', unit: '°C' },
                            { id: 'humidity', name: '湿度', unit: '%' }
                        ],
                        title: '测试组件'
                    },
                    dataSource: {},
                    interaction: {},
                    metadata: {
                        version: '1.0.0',
                        createdAt: Date.now()
                    }
                };

                // 设置旧格式配置
                configurationIntegrationBridge.setConfiguration(testComponentId, oldFormatConfig);
                
                // 获取配置，应该触发自动迁移
                const migratedConfig = configurationIntegrationBridge.getConfiguration(testComponentId);
                
                // 验证迁移结果
                const migrationSuccess = (
                    migratedConfig &&
                    migratedConfig.base.deviceId === 'test-device-123' &&
                    Array.isArray(migratedConfig.base.metricsList) &&
                    migratedConfig.base.metricsList.length === 2 &&
                    !migratedConfig.component.deviceId &&
                    !migratedConfig.component.metricsList &&
                    migratedConfig.metadata.migrationVersion === '2.0'
                );

                testResults.configMigration = migrationSuccess;
                
                if (migrationSuccess) {
                    displayResult('config-migration-result', true, 
                        '配置迁移测试通过', 
                        '\n- deviceId 已迁移到基础配置\n- metricsList 已迁移到基础配置\n- 组件配置中的设备字段已清理\n- 迁移元数据已更新',
                        {
                            before: { component: oldFormatConfig.component },
                            after: { 
                                base: migratedConfig.base,
                                component: migratedConfig.component,
                                migrationMeta: migratedConfig.metadata 
                            }
                        }
                    );
                } else {
                    displayResult('config-migration-result', false,
                        '配置迁移测试失败',
                        '\n- 设备字段迁移不完整或迁移逻辑有误',
                        migratedConfig
                    );
                }

            } catch (error) {
                console.error('配置迁移测试失败:', error);
                testResults.configMigration = false;
                displayResult('config-migration-result', false,
                    '配置迁移测试异常',
                    `\n错误: ${error.message}`
                );
            }
            
            updateOverallStatus();
        };

        // 2. 测试数据源触发机制
        window.testDataSourceTrigger = async function() {
            try {
                console.log('🧪 [ArchitectureFixes] 开始数据源触发机制测试');

                // 这里主要验证架构逻辑，而不是实际的HTTP请求
                const { InteractionManager } = await import('./src/card2.1/core/interaction-manager.js');
                const { PropertyPathManager } = await import('./src/card2.1/core/property-path-manager.js');
                
                // 测试属性路径构建
                const componentId = 'test-component-' + Date.now();
                const deviceIdPath = PropertyPathManager.createBaseConfigBindingPath(componentId, 'deviceId');
                const metricsListPath = PropertyPathManager.createBaseConfigBindingPath(componentId, 'metricsList');
                
                // 验证路径格式
                const correctFormat = (
                    deviceIdPath === `${componentId}.base.deviceId` &&
                    metricsListPath === `${componentId}.base.metricsList`
                );

                // 测试路径解析
                const deviceIdParsed = PropertyPathManager.parseBindingPath(deviceIdPath);
                const parseSuccess = (
                    deviceIdParsed.isValid &&
                    deviceIdParsed.pathInfo.componentInstanceId === componentId &&
                    deviceIdParsed.pathInfo.configSection === 'base' &&
                    deviceIdParsed.pathInfo.propertyPath === 'deviceId' &&
                    deviceIdParsed.pathInfo.hasConfigSection
                );

                testResults.dataSourceTrigger = correctFormat && parseSuccess;

                if (testResults.dataSourceTrigger) {
                    displayResult('datasource-trigger-result', true,
                        '数据源触发机制测试通过',
                        '\n- 属性路径构建正确\n- 路径解析功能正常\n- 配置段信息完整',
                        {
                            deviceIdPath,
                            metricsListPath,
                            parsedInfo: deviceIdParsed.pathInfo
                        }
                    );
                } else {
                    displayResult('datasource-trigger-result', false,
                        '数据源触发机制测试失败',
                        '\n- 路径格式不正确或解析失败',
                        {
                            deviceIdPath,
                            expectedFormat: `${componentId}.base.deviceId`,
                            parsedResult: deviceIdParsed
                        }
                    );
                }

            } catch (error) {
                console.error('数据源触发机制测试失败:', error);
                testResults.dataSourceTrigger = false;
                displayResult('datasource-trigger-result', false,
                    '数据源触发机制测试异常',
                    `\n错误: ${error.message}`
                );
            }
            
            updateOverallStatus();
        };

        // 3. 测试属性暴露
        window.testPropertyExposure = async function() {
            try {
                console.log('🧪 [ArchitectureFixes] 开始属性暴露测试');

                const { propertyExposureRegistry, getBaseConfigurationProperties } = await import('./src/card2.1/core/property-exposure.js');
                
                // 获取基础配置属性
                const baseConfigProperties = getBaseConfigurationProperties();
                
                // 验证关键属性是否存在
                const hasDeviceId = baseConfigProperties.some(p => p.name === 'deviceId');
                const hasMetricsList = baseConfigProperties.some(p => p.name === 'metricsList');
                const hasVisibility = baseConfigProperties.some(p => p.name === 'visible');
                
                // 测试组件注册
                const testComponentType = 'test-exposure-component';
                
                // 模拟组件定义并注册
                const { ComponentRegistry } = await import('./src/card2.1/core/component-registry.js');
                ComponentRegistry.register({
                    type: testComponentType,
                    label: '测试暴露组件',
                    dataSources: [],
                    staticParams: {}
                });
                
                // 获取注册后的属性暴露配置
                const exposureConfig = propertyExposureRegistry.getComponentExposure(testComponentType);
                
                const registrationSuccess = (
                    exposureConfig &&
                    exposureConfig.listenableProperties.some(p => p.name === 'deviceId') &&
                    exposureConfig.listenableProperties.some(p => p.name === 'metricsList')
                );

                testResults.propertyExposure = hasDeviceId && hasMetricsList && hasVisibility && registrationSuccess;

                if (testResults.propertyExposure) {
                    displayResult('property-exposure-result', true,
                        '属性暴露测试通过',
                        '\n- 基础配置属性定义完整\n- 组件注册时包含基础配置属性\n- deviceId 和 metricsList 可用于绑定',
                        {
                            baseConfigPropertiesCount: baseConfigProperties.length,
                            coreProperties: ['deviceId', 'metricsList', 'visible'],
                            registeredComponent: exposureConfig?.componentName,
                            exposedPropertiesCount: exposureConfig?.listenableProperties.length
                        }
                    );
                } else {
                    displayResult('property-exposure-result', false,
                        '属性暴露测试失败',
                        '\n- 基础配置属性缺失或组件注册失败',
                        {
                            baseConfigProperties: baseConfigProperties.map(p => p.name),
                            exposureConfig: exposureConfig
                        }
                    );
                }

            } catch (error) {
                console.error('属性暴露测试失败:', error);
                testResults.propertyExposure = false;
                displayResult('property-exposure-result', false,
                    '属性暴露测试异常',
                    `\n错误: ${error.message}`
                );
            }
            
            updateOverallStatus();
        };

        // 4. 测试属性路径格式
        window.testPropertyPathFormat = async function() {
            try {
                console.log('🧪 [ArchitectureFixes] 开始属性路径格式测试');

                const { PropertyPathManager } = await import('./src/card2.1/core/property-path-manager.js');
                
                const testComponentId = 'simple-display_1757236004299';
                
                // 测试新的正确路径格式
                const baseConfigPath = PropertyPathManager.createBaseConfigBindingPath(testComponentId, 'deviceId');
                const componentConfigPath = PropertyPathManager.createComponentConfigBindingPath(testComponentId, 'title');
                
                // 期望的正确格式
                const expectedBasePath = `${testComponentId}.base.deviceId`;
                const expectedComponentPath = `${testComponentId}.component.title`;
                
                // 验证格式
                const formatCorrect = (
                    baseConfigPath === expectedBasePath &&
                    componentConfigPath === expectedComponentPath
                );

                // 测试解析功能
                const baseParsed = PropertyPathManager.parseBindingPath(baseConfigPath);
                const componentParsed = PropertyPathManager.parseBindingPath(componentConfigPath);
                
                const parseCorrect = (
                    baseParsed.isValid && baseParsed.pathInfo.configSection === 'base' &&
                    componentParsed.isValid && componentParsed.pathInfo.configSection === 'component'
                );

                testResults.propertyPath = formatCorrect && parseCorrect;

                if (testResults.propertyPath) {
                    displayResult('property-path-result', true,
                        '属性路径格式测试通过',
                        '\n- 基础配置路径格式正确\n- 组件配置路径格式正确\n- 路径解析功能正常',
                        {
                            examples: {
                                baseConfig: baseConfigPath,
                                componentConfig: componentConfigPath,
                                oldWrongFormat: `${testComponentId}.deviceId`,
                                newCorrectFormat: expectedBasePath
                            },
                            parseResults: {
                                base: baseParsed.pathInfo,
                                component: componentParsed.pathInfo
                            }
                        }
                    );
                } else {
                    displayResult('property-path-result', false,
                        '属性路径格式测试失败',
                        '\n- 路径格式不符合预期或解析失败',
                        {
                            generated: { baseConfigPath, componentConfigPath },
                            expected: { expectedBasePath, expectedComponentPath },
                            parsed: { baseParsed, componentParsed }
                        }
                    );
                }

            } catch (error) {
                console.error('属性路径格式测试失败:', error);
                testResults.propertyPath = false;
                displayResult('property-path-result', false,
                    '属性路径格式测试异常',
                    `\n错误: ${error.message}`
                );
            }
            
            updateOverallStatus();
        };

        // 5. 端到端集成测试
        window.testEndToEndFlow = async function() {
            try {
                console.log('🧪 [ArchitectureFixes] 开始端到端集成测试');

                // 这个测试验证整个流程的集成
                const { configurationIntegrationBridge } = await import('./src/components/visual-editor/configuration/ConfigurationIntegrationBridge.js');
                const { PropertyPathManager } = await import('./src/card2.1/core/property-path-manager.js');
                
                const testComponentId = 'e2e-test-' + Date.now();
                
                // 1. 创建包含设备配置的组件配置
                const initialConfig = {
                    base: {
                        deviceId: 'initial-device'
                    },
                    component: {
                        title: '端到端测试组件'
                    },
                    dataSource: {
                        type: 'http',
                        config: {
                            url: 'http://api.example.com/data',
                            params: {
                                deviceId: `${testComponentId}.base.deviceId` // 正确的属性绑定
                            }
                        }
                    },
                    interaction: {},
                    metadata: {
                        version: '2.0.0',
                        createdAt: Date.now()
                    }
                };

                // 2. 设置配置
                configurationIntegrationBridge.setConfiguration(testComponentId, initialConfig);
                
                // 3. 模拟属性变化（设备ID变更）
                const newDeviceId = 'updated-device-456';
                configurationIntegrationBridge.updateConfiguration(testComponentId, 'base', {
                    ...initialConfig.base,
                    deviceId: newDeviceId
                });

                // 4. 验证配置更新
                const updatedConfig = configurationIntegrationBridge.getConfiguration(testComponentId);
                
                // 5. 验证结果
                const integrationSuccess = (
                    updatedConfig &&
                    updatedConfig.base.deviceId === newDeviceId &&
                    updatedConfig.dataSource.config.params.deviceId.includes('.base.deviceId') &&
                    updatedConfig.metadata.updatedAt
                );

                testResults.endToEnd = integrationSuccess;

                if (integrationSuccess) {
                    displayResult('e2e-test-result', true,
                        '端到端集成测试通过',
                        '\n- 组件配置创建成功\n- 基础配置更新成功\n- 属性绑定格式正确\n- 配置变更流程完整',
                        {
                            testFlow: [
                                '1. 创建组件配置（包含属性绑定）',
                                '2. 设置初始配置',
                                '3. 更新基础配置属性',
                                '4. 验证配置更新结果'
                            ],
                            finalConfig: {
                                base: updatedConfig.base,
                                dataSource: updatedConfig.dataSource
                            }
                        }
                    );
                } else {
                    displayResult('e2e-test-result', false,
                        '端到端集成测试失败',
                        '\n- 配置更新流程存在问题',
                        updatedConfig
                    );
                }

            } catch (error) {
                console.error('端到端集成测试失败:', error);
                testResults.endToEnd = false;
                displayResult('e2e-test-result', false,
                    '端到端集成测试异常',
                    `\n错误: ${error.message}`
                );
            }
            
            updateOverallStatus();
        };

        // 页面加载完成后的提示
        window.addEventListener('load', function() {
            console.log('🧪 [ArchitectureFixes] 架构修复验证测试页面已加载');
            console.log('请按顺序点击测试按钮，验证所有架构修复是否生效');
        });
    </script>
</body>
</html>