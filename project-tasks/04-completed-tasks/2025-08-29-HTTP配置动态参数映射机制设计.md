# HTTP配置动态参数映射机制设计

*创建时间: 2025-08-29*  
*基于: SUBTASK-008 HTTP配置需求设计*  
*目标: 设计组件属性与HTTP动态参数的映射绑定机制*

## 🎯 场景需求分析

### 核心场景
```
设备监控组件实例
├── 组件属性: deviceId = "device_001"
├── 用户操作: 切换设备 → deviceId = "device_002"  
├── 属性配置: 为新实例配置不同的deviceId
└── 数据源: HTTP → /api/device/{{deviceId}}/status
```

### 关键需求
1. **属性映射绑定**: 组件属性 ↔ HTTP动态参数的双向绑定
2. **实时响应**: 属性变化 → HTTP参数更新 → 执行器触发
3. **实例隔离**: 相同模板的不同实例参数独立
4. **无后端依赖**: 前端完整的配置管理机制

## 🏗️ 映射机制架构设计

### 1. 参数映射数据结构

```typescript
/**
 * 动态参数映射配置
 * 定义组件属性如何映射到HTTP参数
 */
interface DynamicParameterMapping {
  /** 映射唯一ID */
  mappingId: string
  /** 组件属性路径 (如: 'deviceId', 'config.apiKey') */
  componentPropertyPath: string
  /** HTTP参数名称 (如: 'deviceId', 'authToken') */
  httpParameterName: string
  /** 映射类型 */
  mappingType: 'direct' | 'computed' | 'template'
  /** 数据类型转换 */
  dataType: 'string' | 'number' | 'boolean' | 'json'
  /** 默认值 */
  defaultValue?: any
  /** 映射表达式 (for computed/template) */
  expression?: string
  /** 描述 */
  description?: string
}

/**
 * 组件实例的参数映射配置
 */
interface ComponentParameterMappings {
  /** 组件实例ID */
  componentId: string
  /** 组件类型 */
  componentType: string
  /** 映射配置列表 */
  mappings: DynamicParameterMapping[]
  /** 创建时间 */
  createdAt: number
  /** 更新时间 */
  updatedAt: number
}
```

### 2. 映射管理器 (ParameterMappingManager)

```typescript
/**
 * 动态参数映射管理器
 * 负责组件属性与HTTP参数的映射关系管理
 */
class ParameterMappingManager {
  /** 映射配置存储 */
  private mappings = new Map<string, ComponentParameterMappings>()
  
  /** 属性监听器 */
  private propertyWatchers = new Map<string, (() => void)[]>()
  
  /**
   * 注册组件的参数映射配置
   * @param componentId 组件实例ID
   * @param mappings 映射配置
   */
  registerMappings(componentId: string, mappings: ComponentParameterMappings): void {
    this.mappings.set(componentId, mappings)
    
    // 建立属性监听
    this.setupPropertyWatchers(componentId, mappings)
    
    console.log(`🔗 注册组件参数映射: ${componentId}`, mappings)
  }
  
  /**
   * 获取组件的HTTP参数当前值
   * @param componentId 组件ID
   * @returns HTTP参数键值对
   */
  getHttpParameterValues(componentId: string): Record<string, any> {
    const mappingConfig = this.mappings.get(componentId)
    if (!mappingConfig) return {}
    
    const parameterValues: Record<string, any> = {}
    
    // 获取组件实例
    const component = this.getComponentInstance(componentId)
    if (!component) return {}
    
    // 遍历映射配置，提取参数值
    mappingConfig.mappings.forEach(mapping => {
      const propertyValue = this.getPropertyValue(component, mapping.componentPropertyPath)
      const httpValue = this.transformValue(propertyValue, mapping)
      
      parameterValues[mapping.httpParameterName] = httpValue
    })
    
    return parameterValues
  }
  
  /**
   * 更新组件属性值
   * @param componentId 组件ID  
   * @param propertyPath 属性路径
   * @param newValue 新值
   */
  updateComponentProperty(componentId: string, propertyPath: string, newValue: any): void {
    const component = this.getComponentInstance(componentId)
    if (!component) return
    
    // 更新组件属性
    this.setPropertyValue(component, propertyPath, newValue)
    
    // 触发HTTP参数更新
    this.triggerParameterUpdate(componentId, propertyPath)
    
    console.log(`🔄 更新组件属性: ${componentId}.${propertyPath} = ${newValue}`)
  }
  
  /**
   * 建立属性监听器
   */
  private setupPropertyWatchers(componentId: string, mappingConfig: ComponentParameterMappings): void {
    const component = this.getComponentInstance(componentId)
    if (!component) return
    
    // 为每个映射建立监听器
    mappingConfig.mappings.forEach(mapping => {
      const unwatch = this.watchProperty(component, mapping.componentPropertyPath, (oldValue, newValue) => {
        console.log(`👀 属性变化监听: ${componentId}.${mapping.componentPropertyPath}`, { oldValue, newValue })
        
        // 触发HTTP参数更新
        this.triggerParameterUpdate(componentId, mapping.componentPropertyPath)
      })
      
      // 存储清理函数
      if (!this.propertyWatchers.has(componentId)) {
        this.propertyWatchers.set(componentId, [])
      }
      this.propertyWatchers.get(componentId)!.push(unwatch)
    })
  }
  
  /**
   * 触发HTTP参数更新
   */
  private triggerParameterUpdate(componentId: string, propertyPath: string): void {
    // 获取更新后的所有HTTP参数值
    const httpParams = this.getHttpParameterValues(componentId)
    
    // 通过DataWarehouse更新动态参数
    Object.entries(httpParams).forEach(([paramName, paramValue]) => {
      const globalParamName = `${componentId}_${paramName}` // 实例级别隔离
      dataWarehouse.updateDynamicParameter(globalParamName, paramValue)
    })
    
    console.log(`🚀 触发HTTP参数更新: ${componentId}`, httpParams)
  }
  
  /**
   * 获取组件实例 (集成现有组件系统)
   */
  private getComponentInstance(componentId: string): any {
    // 从ConfigurationPanel或VisualEditor获取组件实例
    return visualEditor.getComponentById(componentId) || null
  }
  
  /**
   * 监听属性变化 (Vue3响应式系统)
   */
  private watchProperty(component: any, propertyPath: string, callback: (oldValue: any, newValue: any) => void): () => void {
    // 使用Vue3的watch API监听属性变化
    return watch(
      () => this.getPropertyValue(component, propertyPath),
      (newValue, oldValue) => callback(oldValue, newValue),
      { deep: true }
    )
  }
  
  /**
   * 获取属性值 (支持嵌套路径)
   */
  private getPropertyValue(component: any, propertyPath: string): any {
    return propertyPath.split('.').reduce((obj, key) => obj?.[key], component)
  }
  
  /**
   * 设置属性值 (支持嵌套路径)
   */
  private setPropertyValue(component: any, propertyPath: string, value: any): void {
    const keys = propertyPath.split('.')
    const lastKey = keys.pop()!
    const target = keys.reduce((obj, key) => obj[key], component)
    
    if (target && lastKey) {
      target[lastKey] = value
    }
  }
  
  /**
   * 值类型转换
   */
  private transformValue(value: any, mapping: DynamicParameterMapping): any {
    if (value === undefined || value === null) {
      return mapping.defaultValue
    }
    
    switch (mapping.mappingType) {
      case 'direct':
        return this.convertDataType(value, mapping.dataType)
      
      case 'computed':
        // 执行计算表达式
        return this.evaluateExpression(mapping.expression!, { value })
      
      case 'template':
        // 模板字符串替换
        return mapping.expression!.replace(/\{\{value\}\}/g, String(value))
      
      default:
        return value
    }
  }
  
  /**
   * 数据类型转换
   */
  private convertDataType(value: any, dataType: string): any {
    switch (dataType) {
      case 'string': return String(value)
      case 'number': return Number(value)
      case 'boolean': return Boolean(value)
      case 'json': return JSON.stringify(value)
      default: return value
    }
  }
  
  /**
   * 表达式求值 (简单实现)
   */
  private evaluateExpression(expression: string, context: any): any {
    try {
      return new Function('context', `with(context) { return ${expression} }`)(context)
    } catch (error) {
      console.error('表达式求值失败:', expression, error)
      return context.value
    }
  }
  
  /**
   * 清理组件映射
   */
  cleanup(componentId: string): void {
    // 清理属性监听器
    const watchers = this.propertyWatchers.get(componentId)
    if (watchers) {
      watchers.forEach(unwatch => unwatch())
      this.propertyWatchers.delete(componentId)
    }
    
    // 删除映射配置
    this.mappings.delete(componentId)
    
    console.log(`🧹 清理组件映射: ${componentId}`)
  }
}

// 创建全局实例
export const parameterMappingManager = new ParameterMappingManager()
```

### 3. HTTP配置模板系统

```typescript
/**
 * HTTP配置模板
 * 支持动态参数占位符
 */
interface HttpConfigTemplate {
  /** 模板ID */
  templateId: string
  /** 模板名称 */
  name: string
  /** HTTP配置模板 */
  httpConfig: {
    url: string  // 如: '/api/device/{{deviceId}}/status'
    method: string
    headers: HttpHeader[]  // 支持动态参数
    params: HttpParam[]    // 支持动态参数
  }
  /** 参数映射配置 */
  parameterMappings: DynamicParameterMapping[]
  /** 描述 */
  description?: string
}

/**
 * HTTP配置模板管理器
 */
class HttpConfigTemplateManager {
  private templates = new Map<string, HttpConfigTemplate>()
  
  /**
   * 注册HTTP配置模板
   */
  registerTemplate(template: HttpConfigTemplate): void {
    this.templates.set(template.templateId, template)
    console.log(`📋 注册HTTP配置模板: ${template.templateId}`)
  }
  
  /**
   * 为组件实例应用模板
   * @param componentId 组件实例ID
   * @param templateId 模板ID
   * @param propertyBindings 属性绑定配置
   */
  applyTemplate(componentId: string, templateId: string, propertyBindings: Record<string, string>): void {
    const template = this.templates.get(templateId)
    if (!template) {
      console.error(`模板不存在: ${templateId}`)
      return
    }
    
    // 创建实例级别的映射配置
    const instanceMappings: ComponentParameterMappings = {
      componentId,
      componentType: 'http-data-component',
      mappings: template.parameterMappings.map(mapping => ({
        ...mapping,
        mappingId: `${componentId}_${mapping.mappingId}`,
        componentPropertyPath: propertyBindings[mapping.httpParameterName] || mapping.componentPropertyPath
      })),
      createdAt: Date.now(),
      updatedAt: Date.now()
    }
    
    // 注册到映射管理器
    parameterMappingManager.registerMappings(componentId, instanceMappings)
    
    // 生成HTTP配置
    const httpConfig = this.generateHttpConfig(componentId, template)
    
    // 保存到ConfigurationManager
    const dataSourceConfig = {
      type: 'http',
      enabled: true,
      config: httpConfig,
      metadata: {
        templateId,
        mappings: instanceMappings,
        updatedAt: Date.now()
      }
    }
    
    configurationManager.updateConfiguration(componentId, 'dataSource', dataSourceConfig)
    
    console.log(`✅ 为组件应用HTTP模板: ${componentId} → ${templateId}`)
  }
  
  /**
   * 生成实例化的HTTP配置
   */
  private generateHttpConfig(componentId: string, template: HttpConfigTemplate): any {
    // 获取当前参数值
    const parameterValues = parameterMappingManager.getHttpParameterValues(componentId)
    
    // 替换URL中的占位符
    let url = template.httpConfig.url
    Object.entries(parameterValues).forEach(([paramName, paramValue]) => {
      url = url.replace(new RegExp(`\\{\\{${paramName}\\}\\}`, 'g'), String(paramValue))
    })
    
    // 生成Headers配置
    const headers = template.httpConfig.headers.map(header => ({
      ...header,
      value: header.isDynamic 
        ? (parameterValues[header.variableName] || header.value)
        : header.value
    }))
    
    // 生成Params配置
    const params = template.httpConfig.params.map(param => ({
      ...param,
      value: param.isDynamic
        ? (parameterValues[param.variableName] || param.value)
        : param.value
    }))
    
    return {
      url,
      method: template.httpConfig.method,
      headers,
      params,
      timeout: 5000
    }
  }
}

export const httpConfigTemplateManager = new HttpConfigTemplateManager()
```

## 🔄 完整工作流程示例

### 1. 模板定义阶段

```typescript
// 定义设备状态查询HTTP模板
const deviceStatusTemplate: HttpConfigTemplate = {
  templateId: 'device-status-query',
  name: '设备状态查询',
  httpConfig: {
    url: '/api/device/{{deviceId}}/status',
    method: 'GET',
    headers: [
      {
        key: 'Authorization',
        value: 'Bearer {{authToken}}',
        enabled: true,
        isDynamic: true,
        dataType: 'string',
        variableName: 'authToken',
        description: '认证令牌'
      }
    ],
    params: [
      {
        key: 'includeMetrics',
        value: '{{includeMetrics}}',
        enabled: true,
        isDynamic: true,
        dataType: 'boolean',
        variableName: 'includeMetrics', 
        description: '是否包含指标数据'
      }
    ]
  },
  parameterMappings: [
    {
      mappingId: 'deviceId-mapping',
      componentPropertyPath: 'deviceId',
      httpParameterName: 'deviceId',
      mappingType: 'direct',
      dataType: 'string',
      description: '设备ID直接映射'
    },
    {
      mappingId: 'authToken-mapping', 
      componentPropertyPath: 'config.apiKey',
      httpParameterName: 'authToken',
      mappingType: 'template',
      dataType: 'string',
      expression: 'Bearer {{value}}',
      description: 'API密钥转换为认证令牌'
    },
    {
      mappingId: 'includeMetrics-mapping',
      componentPropertyPath: 'showMetrics',
      httpParameterName: 'includeMetrics', 
      mappingType: 'direct',
      dataType: 'boolean',
      defaultValue: false,
      description: '显示指标开关映射'
    }
  ]
}

// 注册模板
httpConfigTemplateManager.registerTemplate(deviceStatusTemplate)
```

### 2. 组件实例创建阶段

```typescript
// 创建设备监控组件实例A
const componentA = {
  id: 'device-monitor-001',
  type: 'device-status-widget',
  properties: {
    deviceId: 'device_001',
    config: {
      apiKey: 'abc123'
    },
    showMetrics: true
  }
}

// 应用HTTP模板到组件A
httpConfigTemplateManager.applyTemplate(
  'device-monitor-001',
  'device-status-query',
  {
    deviceId: 'deviceId',          // HTTP参数名 → 组件属性路径
    authToken: 'config.apiKey',
    includeMetrics: 'showMetrics'
  }
)

// 创建相同类型的组件实例B
const componentB = {
  id: 'device-monitor-002', 
  type: 'device-status-widget',
  properties: {
    deviceId: 'device_002',
    config: {
      apiKey: 'xyz789'
    },
    showMetrics: false
  }
}

// 应用相同模板到组件B
httpConfigTemplateManager.applyTemplate(
  'device-monitor-002',
  'device-status-query',
  {
    deviceId: 'deviceId',
    authToken: 'config.apiKey', 
    includeMetrics: 'showMetrics'
  }
)
```

### 3. 运行时动态更新

```typescript
// 用户操作: 切换组件A的设备
function onDeviceSwitch(componentId: string, newDeviceId: string) {
  // 更新组件属性
  parameterMappingManager.updateComponentProperty(componentId, 'deviceId', newDeviceId)
  
  // 这将自动触发:
  // 1. 属性监听器感知变化
  // 2. HTTP参数值更新  
  // 3. DataWarehouse动态参数更新
  // 4. ConfigEventBus事件触发
  // 5. HttpExecutor重新执行
}

// 用户操作示例
onDeviceSwitch('device-monitor-001', 'device_003')

// 属性配置: 为组件B配置不同的API密钥
parameterMappingManager.updateComponentProperty('device-monitor-002', 'config.apiKey', 'newkey456')
```

### 4. HTTP执行器集成

```typescript
// HTTP执行器接收到的最终配置 (组件A)
const resolvedConfigA = {
  url: '/api/device/device_003/status',  // deviceId已替换
  method: 'GET',
  headers: [
    {
      key: 'Authorization',
      value: 'Bearer abc123',           // authToken已替换
      enabled: true,
      isDynamic: false                  // 执行时已是静态值
    }
  ],
  params: [
    {
      key: 'includeMetrics', 
      value: true,                      // showMetrics已转换
      enabled: true,
      isDynamic: false
    }
  ]
}

// HTTP执行器接收到的最终配置 (组件B)  
const resolvedConfigB = {
  url: '/api/device/device_002/status',  // 不同的deviceId
  method: 'GET',
  headers: [
    {
      key: 'Authorization',
      value: 'Bearer newkey456',         // 不同的authToken
      enabled: true,
      isDynamic: false
    }
  ],
  params: [
    {
      key: 'includeMetrics',
      value: false,                      // 不同的includeMetrics
      enabled: true, 
      isDynamic: false
    }
  ]
}
```

## 🔗 与现有架构的集成

### DataWarehouse集成

```typescript
// 参数命名空间隔离
const parameterKey = `${componentId}_${httpParameterName}`

// 更新动态参数
dataWarehouse.updateDynamicParameter(parameterKey, parameterValue)

// 订阅参数变化
dataWarehouse.subscribeDynamicParameter(parameterKey, (oldValue, newValue) => {
  // 触发HTTP配置重新生成
  regenerateHttpConfig(componentId)
})
```

### ConfigurationManager集成

```typescript
// 保存映射关系到配置
const dataSourceConfig = {
  type: 'http-dynamic',
  config: httpConfig,
  metadata: {
    templateId: 'device-status-query',
    parameterMappings: mappings,
    dynamicParameters: parameterValues
  }
}

configurationManager.updateConfiguration(componentId, 'dataSource', dataSourceConfig)
```

### ConfigEventBus集成

```typescript
// 参数变化触发配置事件
configEventBus.emitConfigChange({
  componentId,
  section: 'dataSource',
  changeType: 'dynamic-parameter-changed',
  dynamicParameterName: parameterName,
  oldConfig: { [parameterName]: oldValue },
  newConfig: { [parameterName]: newValue }
})
```

## 🎯 关键特性总结

### 1. 实例级别隔离
- 相同模板的不同实例拥有独立的参数空间
- 参数命名规则: `${componentId}_${parameterName}`
- 避免不同实例间的参数冲突

### 2. 响应式映射
- Vue3响应式系统自动监听属性变化
- 属性变化 → HTTP参数更新 → 执行器触发
- 支持深层嵌套属性监听

### 3. 灵活的映射类型
- **direct**: 直接值映射
- **computed**: 表达式计算  
- **template**: 模板字符串替换

### 4. 模板复用机制
- 定义一次模板，多个实例复用
- 支持不同的属性绑定配置
- 降低重复配置工作量

### 5. 无后端依赖
- 前端完整的配置管理和存储
- 基于现有ConfigurationManager
- 支持配置的导入导出

这个设计完美解决了你提到的场景需求，实现了组件属性与HTTP动态参数的灵活映射绑定！
