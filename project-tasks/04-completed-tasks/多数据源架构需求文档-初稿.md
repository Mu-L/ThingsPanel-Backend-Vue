# 多数据源配置系统架构需求文档（初稿）

**文档版本**: v0.1  
**创建时间**: 2024-08-27  
**创建人**: Claude  
**状态**: 初稿待完善  

---

## 🎯 系统概述

多数据源配置系统允许组件配置多个独立的数据源，每个数据源包含多个数据项，通过执行器处理后为组件提供所需数据。

## 🏗️ 核心架构

### 三层层次结构
```
Component (组件)
├── DataSource 1 (数据源1)
│   ├── DataItem 1 (数据项1 - JSON类型)
│   ├── DataItem 2 (数据项2 - HTTP类型) 
│   ├── DataItem N (数据项N - 其他类型)
│   └── MergeStrategy (合并策略) → DataSource Result (数据源最终结果)
├── DataSource 2 (数据源2)
│   └── ...
└── DataSource 3 (数据源3)
    └── ...
```

### 数据处理管道
```
单个数据项处理: 原始输入 → 数据获取器 → 数据过滤器 → 脚本处理器 → 处理后数据项

完整数据源处理: 
数据项1 → 处理后数据项1 ↘
数据项2 → 处理后数据项2 → 合并处理器 → 数据源最终结果
数据项N → 处理后数据项N ↗
```

## 📋 详细需求规格

### 1. 组件数据源声明
- 组件在定义文件中声明需要的数据源数量和配置
- 参考文件: `/src/card2.1/components/triple-data-display/definition.ts`
- 每个数据源有独立的配置表单（ 使用 折叠面板）

### 2. 数据项类型支持

#### 2.1 JSON类型数据项
**第一步 - 数据获取**:
- 选择JSON类型
- 输入JSON字符串
- 执行：`JSON.parse(jsonString)` → 原始数据对象

#### 2.2 HTTP类型数据项
**第一步 - 数据获取**:
- 配置请求地址（URL）
- 配置请求方式（GET/POST/PUT/DELETE等）
- 配置请求头（Headers）- 数组格式录入，执行时转换为对象
- 配置请求参数（Params）- 数组格式录入，执行时转换为对象
- 动态参数配置：
  - 勾选框标记哪些参数是动态的
  - 动态参数必须录入示例值（用于模拟请求测试）
  - 动态参数来源配置（外部如何传入最终值）
  -请求头也可能动态
- 请求前脚本（处理请求参数）
- 响应后脚本（处理响应数据）
- 执行：`HTTP请求 + 脚本处理` → 原始数据对象

#### HTTP配置的特殊处理需求

##### 2.2.1 数组转对象处理
**录入格式（数组）**:
```javascript
headers: [
  {key: 'Content-Type', value: 'application/json', isDynamic: false},
  {key: 'Authorization', value: 'Bearer {{token}}', isDynamic: true, example: 'Bearer test123'}
]

params: [
  {key: 'deviceId', value: '{{deviceId}}', isDynamic: true, example: 'device001'},
  {key: 'limit', value: '10', isDynamic: false}
]
```

**执行时转换（对象）**:
```javascript
headers: {
  'Content-Type': 'application/json',
  'Authorization': 'Bearer actualToken'  // 动态替换
}

params: {
  'deviceId': 'actualDeviceId',  // 动态替换
  'limit': '10'
}
```

##### 2.2.2 动态参数处理机制
**示例值的作用**:
- 配置阶段：使用示例值进行模拟请求测试
- 运行阶段：使用实际动态值进行真实请求

**动态参数值的传入方式**:
1. **全局状态注入**：从全局store获取
2. **组件属性注入**：从父组件props传入
3. **事件触发注入**：响应用户操作时传入
4. **其他数据源注入**：从同组件其他数据源获取

**动态参数变化处理**:
```javascript
// 动态参数变化时，需要重新执行HTTP请求
onDynamicParamChange(paramName, newValue) {
  // 1. 更新参数值
  updateDynamicParam(paramName, newValue)
  // 2. 重新执行数据获取
  reExecuteHttpRequest()
  // 3. 触发数据流更新
  triggerDataUpdate()
}
```

##### 2.2.3 动态参数实际应用场景分析

**典型场景：设备指标数据接口**
```
接口: GET /api/device/metrics?deviceId={{deviceId}}&metric={{metric}}
动态参数: deviceId, metric
```

**场景1：组件属性配置方式**
- 在组件属性配置中通过下拉选择设备和指标
- 不同卡片实例配置不同的设备ID和指标
- 参数值在组件配置阶段确定，运行时不变

**场景2：组件内切换方式**  
- 组件内部提供设备/指标切换功能
- 用户通过UI操作切换查看不同设备的数据
- 参数值在运行时动态变化

##### 2.2.4 动态参数"双盲"绑定机制设计

**核心问题**：组件先存在，数据源后配置，两者如何建立动态参数的绑定关系？

**方案1：组件声明 + 用户手动绑定**
```typescript
// 组件声明可用的动态参数
const componentDynamicParams = {
  currentDeviceId: { type: 'string', description: '当前选中的设备ID' },
  currentMetric: { type: 'string', description: '当前选中的指标' }
}

// 数据源配置时，用户手动建立绑定关系
const httpConfig = {
  url: '/api/device/metrics',
  params: [
    {
      key: 'deviceId',
      value: '{{deviceId}}',
      isDynamic: true,
      bindTo: 'component.currentDeviceId' // 手动绑定到组件参数
    },
    {
      key: 'metric',
      value: '{{metric}}',
      isDynamic: true,
      bindTo: 'component.currentMetric' // 手动绑定到组件参数
    }
  ]
}
```

**✅ 确定方案：特殊选择器绑定**
```typescript
// 配置界面提供特殊的"动态参数选择器"
interface DynamicParamSelector {
  availableParams: ComponentDynamicParam[] // 组件提供的可用参数
  selectedParam?: string // 用户选择绑定的参数
  isUsed: boolean // 是否已被其他地方使用
}

// 动态参数配置结构
const paramConfig = {
  key: 'deviceId',
  value: '', // 如果绑定了动态参数，这里为空
  isDynamic: true,
  dynamicBinding: {
    source: 'component.currentDeviceId',
    isAvailable: true, // 该参数是否还可用
    isSelected: true   // 用户是否选择绑定
  }
}

// 配置界面交互流程
const bindingFlow = {
  step1: '用户勾选参数为动态参数',
  step2: '显示动态参数选择器',
  step3: '列出组件可用参数（显示使用状态）',
  step4: '用户选择绑定的组件参数',
  step5: '建立绑定关系，更新参数使用状态',
  step6: '该组件参数变为"已使用"，其他地方不可选'
}
```

**方案3：自动协商机制**
```typescript
// 组件声明需求
component.declareDynamicNeeds(['deviceId', 'metric'])

// 数据源配置检测匹配
dataSource.detectAvailableParams() // 返回 ['currentDeviceId', 'currentMetric']

// 自动或半自动建立映射关系
const autoMapping = {
  'deviceId' -> 'currentDeviceId', // 基于语义相似性
  'metric' -> 'currentMetric'
}
```

##### 2.2.5 绑定关系管理

**绑定约束**：
- 一个组件动态参数只能绑定到一个数据源参数
- 一个数据源参数可以绑定多个组件动态参数（但通常不建议）
- 绑定关系建立后，参数值实时同步

**绑定状态管理**：
```typescript
interface ParamBindingManager {
  // 记录绑定关系
  bindings: Map<string, string> // dataSourceParam -> componentParam
  
  // 检查参数可用性
  isParamAvailable(componentParam: string): boolean
  
  // 建立绑定关系
  createBinding(dataSourceParam: string, componentParam: string): void
  
  // 解除绑定关系
  removeBinding(dataSourceParam: string): void
  
  // 获取参数当前值
  getParamValue(componentParam: string): any
}
```

**配置界面交互流程**：
```
1. 用户配置HTTP参数时，标记为动态参数
2. 系统显示"参数绑定选择器"
3. 选择器显示组件可用的动态参数列表
4. 显示每个参数的使用状态（已绑定/可用）
5. 用户选择绑定关系
6. 建立绑定，该组件参数变为"已使用"状态
```

#### 2.3 自定义脚本类型数据项
**第一步 - 数据获取**:
- 编写自定义脚本代码
- 执行：`customScript()` → 原始数据对象

#### 2.4 统一的第二步处理（与类型无关）
**所有类型的数据项获得原始数据后，都执行相同的处理步骤**:

1. **数据过滤**（可选）:
   - 配置JSONPath过滤路径（如：`$.abc.bdc[6]`）
   - 执行：从原始数据中提取所需部分

2. **脚本处理**（可选）:
   - 编写数据处理脚本（如：将name改为username）
   - 执行：对数据进行自定义转换

**统一的执行流程**:
```
任意类型获取 → 原始数据对象 → JSONPath过滤 → 脚本处理 → 处理后数据项
```

#### 2.5 其他类型（WebSocket等）
- 当前版本不实现
- 预留扩展接口

### 3. 数据源合并策略

一个数据源内多个处理后数据项的合并策略（本质上都是预制脚本）：

#### 3.1 条件选择脚本（优先实现）
- **选择第一个可用**: 返回第一个非空数据项
- **选择最大数据集**: 返回数据量最大的数据项  
- **按优先级选择**: 按数据项配置顺序选择
- **条件过滤选择**: 按自定义条件选择符合要求的数据项

#### 3.2 简单合并脚本（容易实现）
- **组成数组**: `[item1, item2, item3]` (最直接的合并)
- **对象浅合并**: `Object.assign({}, item1, item2, ...)` (简单对象合并)
- **数组展开合并**: `[...item1, ...item2, ...]` (假设都是数组的情况)

#### 3.3 自定义脚本
```javascript
// 完全自定义的合并逻辑
function customMergeScript(processedDataItems) {
  // processedDataItems = [item1, item2, item3, ...]
  // 用户编写任意合并逻辑，处理各种未知数据格式
  return customResult;
}
```

#### 实现策略
**由于用户数据是未知数，重点在于**:
- 优先实现简单可靠的预制脚本
- 重点依靠自定义脚本处理复杂场景
- 预制脚本只解决最常见的合并需求

### 4. 三层执行器架构

#### 4.1 第一层执行器：数据获取器
**职责**: 根据数据项类型和配置获取原始数据
- **JSON类型**：`JSON.parse(jsonString)` → 原始数据对象
- **HTTP类型**：`HTTP请求 + 请求前后脚本` → 原始数据对象  
- **脚本类型**：`customScript()` → 原始数据对象
- **输出**：统一的原始数据对象（与类型无关）

#### 4.2 第二层执行器：数据处理器（类型无关）
**职责**: 对任何原始数据进行统一的过滤和处理
- **数据过滤**：使用JSONPath语法（`$`, `$.abc`, `$.abc.bcd[6]`等）
- **脚本处理**：执行用户自定义处理脚本
- **输入**：原始数据对象（来自任意类型的获取器）
- **输出**：处理后数据项

**关键点**: 第二步处理与数据来源类型完全无关，只处理统一的数据对象

#### 4.3 第三层执行器：合并处理器
**职责**: 将多个处理后数据项合并为数据源最终结果
- 条件选择：按设定条件选择其中一项数据项
- 对象合并：将多个数据项合并为一个对象
- 数组合并：将多个数据项组成数组
- 脚本处理：用户自定义合并逻辑

**完整执行流程**:
```
N个数据项 → N个(获取器+处理器) → N个处理后数据项 → 合并处理器 → 数据源最终结果
```

### 5. 实时执行机制

#### 5.1 执行时机
- 初始状态：执行器产生空对象，组件获得空对象
- 配置变化：每次配置修改后自动执行
- 动态参数变化：相关动态参数改变时重新执行

#### 5.2 执行流程
1. 用户进入配置界面
2. 显示数据源配置表单（基于组件定义）
3. 用户添加/修改数据项配置
4. 执行器自动运行处理数据
5. 实时更新组件显示效果

## 🔧 技术实现要点

### 1. JSONPath过滤器
支持的语法：
- `$` - 根对象
- `$.abc` - 对象属性
- `$.abc.bcd` - 嵌套对象属性
- `$[0]` - 数组索引
- `$.abc[0]` - 对象属性的数组索引
- `$.abc.bcd[6]` - 复杂路径示例

### 2. 脚本执行环境
- JavaScript引擎（具体引擎待确定）
- 脚本类型：
  - 数据处理脚本
  - HTTP请求前脚本
  - HTTP响应后脚本
  - 数据源合并脚本
- 错误处理机制
- 安全沙箱环境

### 3. 动态参数系统
- 参数来源识别（全局状态、其他组件、用户输入等）
- 参数变化监听和自动重新执行
- 参数配置界面设计

## 📊 用户体验流程

### 典型配置场景
1. 用户打开triple-data-display组件配置
2. 看到三个数据源的配置表单
3. 配置数据源1：
   - 添加JSON数据项 → 输入JSON → 设置过滤`$.abc.bdc[6]` → 编写处理脚本
   - 添加HTTP数据项 → 配置接口 → 设置动态参数 → 编写请求/响应脚本
   - 选择合并策略（数组/对象/单选/脚本）
4. 实时看到数据源1的最终结果
5. 继续配置数据源2和数据源3
6. 组件获得三个数据源的最终数据并显示

## ❓ 待明确的技术细节

### 1. 组件定义规范
- 组件如何在definition.ts中声明数据源需求？
- 数据源的类型定义和接口规范？

### 2. HTTP动态参数系统（重要）
基于设备指标数据场景的具体问题：

- **参数来源配置**：配置界面如何让用户选择参数来源？
  - 静态配置：下拉选择设备ID和指标
  - 动态绑定：绑定到组件内部状态
  - 全局绑定：绑定到全局设备状态

- **参数变化监听机制**：
  - 组件内部状态变化如何触发数据源更新？
  - 全局设备切换如何影响所有相关组件？
  - 多个参数同时变化的防抖处理？

- **"双盲"绑定机制选择**：
  - 采用哪种绑定方案？手动绑定、选择器绑定、还是自动协商？
  - 组件如何声明可用的动态参数？
  - 数据源配置时如何展示和选择绑定关系？

- **绑定关系管理**：
  - 绑定关系的存储和持久化方式？
  - 参数使用状态如何实时更新？
  - 绑定冲突如何处理和提示？

- **配置界面交互设计**：
  - "参数绑定选择器"的具体UI交互？
  - 参数可用性状态如何直观显示？
  - 绑定建立和解除的操作流程？

- **运行时参数传递**：
  - 组件参数值变化如何通知数据源系统？
  - 参数值的实时同步机制？
  - 多个数据源绑定同一参数时的更新策略？

### 3. 数据转换和处理
- **数组转对象算法**：Headers和Params数组转对象的具体实现？
- **动态参数替换机制**：如何在字符串中识别和替换`{{paramName}}`？
- **示例值 vs 实际值**：配置阶段和运行阶段的数据切换机制？

### 4. 脚本引擎选择
- 使用哪种JavaScript执行环境？
- 脚本的安全限制和可用API？

### 5. 错误处理策略
- HTTP请求失败如何处理？
- 动态参数缺失时的处理策略？
- 脚本执行错误如何显示给用户？
- 数据解析失败的降级策略？

### 6. 性能优化
- 动态参数变化时如何避免频繁的HTTP请求？
- 数据缓存机制设计？
- 大数据量的处理优化？

### 7. 调试和预览功能
- 如何提供HTTP请求的数据预览功能？
- 动态参数的测试和调试工具？
- 脚本调试工具设计？
- 配置过程中的错误提示机制？

---

## ✅ 需求沟通阶段性成果

**已确认的关键决策**：
- ✅ 三层执行器架构：数据获取器 → 数据处理器 → 合并处理器
- ✅ 第二步处理与数据类型无关，统一处理原始数据对象
- ✅ 合并策略采用预制脚本概念，重点实现简单可靠的合并方式
- ✅ 动态参数绑定采用方案2：特殊选择器绑定
- ✅ HTTP配置采用数组格式录入，执行时转换为对象

**明确的技术要点**：
- HTTP动态参数必须提供示例值用于模拟测试
- 组件参数与数据源参数"一对一"绑定，"挂一个少一个"
- 数据源配置通过可视化选择器建立参数绑定关系
- 预制脚本优先实现条件选择和简单合并，复杂场景依赖自定义脚本

**待细化的实现细节**：
- 参数绑定选择器的具体UI交互设计
- 数组转对象的转换算法实现
- 动态参数变化的实时同步机制
- 组件如何声明可用动态参数的接口设计

**本阶段沟通目标达成**：架构设计基本确定，为后续详细设计和实现奠定了基础。