# SUBTASK-008: HTTP配置需求设计（完整版）

*创建时间: 2025-08-29*  
*任务状态: 需求设计完成*  
*文档版本: v2.0*  
*任务目标: 设计完整的HTTP数据源配置系统，支持动态参数映射、脚本处理和性能优化*

---

## 📋 文档概览

本文档设计了一个完整的HTTP配置系统，包含以下核心部分：

- **🔧 技术架构设计** - HttpExecutor增强、类型系统扩展、性能优化机制
- **🎨 UI表单设计** - 5标签页配置界面，集成ConfigurationPanel
- **🔗 组件映射机制** - Card2.1双盲映射系统，支持组件属性与HTTP参数绑定
- **📊 实施计划** - 10天完整开发周期，分阶段实施方案

## 🎯 需求概述

### 核心目标
基于现有ThingsPanel架构，设计并实现一个**完整的HTTP数据源配置系统**，支持：

- **🔧 动态参数映射** - 组件属性与HTTP参数的响应式绑定
- **📜 脚本处理能力** - 请求前配置调整和响应后数据转换  
- **⚡ 企业级性能** - 大规模配置下的高效动态参数更新
- **🎨 用户友好界面** - 分层配置UI，降低使用复杂度
- **🔗 无缝组件集成** - 与Card2.1组件系统完美融合

### 设计原则
- **📦 架构复用** - 基于UnifiedDataExecutor、DataWarehouse等现有基础设施
- **🔧 职责分离** - HttpExecutor专注静态执行，动态解析由配置层处理
- **⚡ 性能优先** - 订阅式更新机制，避免大配置重新生成
- **🔄 渐进兼容** - 支持现有HTTP配置格式，平滑升级路径
- **🎯 用户导向** - 降低配置复杂度，提供直观的映射界面

## 📊 现状分析

### 已有基础设施
- **UnifiedDataExecutor.ts**: HTTP执行器基础实现，使用 `@/service/request`
- **@/service/request**: 完整HTTP客户端（认证、多语言、错误处理）  
- **@/core/script-engine**: 脚本执行系统
- **DataWarehouse**: 数据缓存和存储，预留动态参数接口
- **ConfigEventBus**: 配置变更事件系统
- **types/enhanced-types.ts**: 已有HttpHeader和HttpParam基础类型

### 主要缺失
1. **动态参数支持** - 现有配置只支持静态值
2. **脚本集成** - ScriptEngine未集成到HTTP执行器
3. **性能优化** - 动态值变化时需重新生成整个配置

## 🔧 技术方案设计

### 1. 类型系统扩展

#### 扩展现有HTTP类型 (types/enhanced-types.ts)

**HttpHeader接口扩展**:
```typescript
export interface HttpHeader {
  key: string
  value: string                    // 静态时为实际值，动态时为示例值
  enabled: boolean
  isDynamic: boolean              // 改为必填
  dataType: 'string' | 'number' | 'boolean' | 'json'  // 🆕 新增
  variableName: string            // 🆕 自动生成（格式：http_${key}）
  description?: string            // 🆕 参数说明
}
```

**HttpParam接口扩展**:
```typescript  
export interface HttpParam {
  key: string
  value: string                    // 静态时为实际值，动态时为示例值
  enabled: boolean
  isDynamic: boolean              // 改为必填
  dataType: 'string' | 'number' | 'boolean' | 'json'  // 🆕 新增
  variableName: string            // 🆕 自动生成（格式：http_${key}）
  description?: string            // 🆕 参数说明
}
```

**UnifiedDataConfig HTTP配置**:
```typescript
export interface UnifiedDataConfig {
  config: {
    url?: string
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE'
    timeout?: number
    headers?: HttpHeader[]          // 使用扩展后的数组类型
    params?: HttpParam[]            // 使用扩展后的数组类型
    preRequestScript?: string       // 🆕 请求前脚本
    postResponseScript?: string     // 🆕 响应后脚本
  }
}
```

### 2. HttpExecutor增强设计

#### 核心设计原则

**职责明确**: HttpExecutor只处理**静态配置的HTTP请求执行**，不负责动态参数解析

**关键理念**: "参数值变化等于配置变化" - HttpExecutor接收的配置已经是解析后的静态值

#### HttpExecutor增强架构

**执行流程**:
```
静态配置输入 → preRequestScript(调整配置) → HTTP请求 → 响应数据 → postResponseScript(修改结果) → 输出
```

**核心功能模块**:

##### 1. 参数格式转换器 (ParameterTransformer)

```typescript
class ParameterTransformer {
  /**
   * 转换HttpHeader[]为headers对象
   * @param headerConfigs HttpHeader配置数组（已是静态值）
   */
  transformHeaders(headerConfigs: HttpHeader[]): Record<string, string> {
    const result: Record<string, string> = {}
    
    headerConfigs
      .filter(header => header.enabled)
      .forEach(header => {
        result[header.key] = this.convertValue(header.value, header.dataType)
      })
    
    return result
  }
  
  /**
   * 转换HttpParam[]为params对象
   * @param paramConfigs HttpParam配置数组（已是静态值）
   */
  transformParams(paramConfigs: HttpParam[]): Record<string, any> {
    const result: Record<string, any> = {}
    
    paramConfigs
      .filter(param => param.enabled)
      .forEach(param => {
        result[param.key] = this.convertValue(param.value, param.dataType)
      })
    
    return result
  }
  
  /**
   * 根据数据类型转换值
   */
  private convertValue(value: string, dataType: string): any {
    switch (dataType) {
      case 'number': return Number(value)
      case 'boolean': return value === 'true'
      case 'json': return JSON.parse(value)
      default: return value
    }
  }
}
```

##### 2. 脚本处理系统

**preRequestScript**: 调整头和参数的脚本
- **职责**: 修改请求配置（url、headers、params、body等）
- **时机**: HTTP请求前
- **输入**: 当前HTTP配置对象
- **输出**: 修改后的HTTP配置对象

**postResponseScript**: 修改响应结果的脚本  
- **职责**: 处理和转换HTTP响应数据
- **时机**: HTTP响应后，数据转换前
- **输入**: 原始响应数据
- **输出**: 处理后的响应数据

##### 3. HttpExecutor核心实现

```typescript
class EnhancedHttpExecutor implements DataSourceExecutor {
  private paramTransformer = new ParameterTransformer()

  async execute(config: UnifiedDataConfig): Promise<UnifiedDataResult> {
    try {
      // 1. 请求前脚本处理
      let processedConfig = config.config
      if (processedConfig.preRequestScript) {
        processedConfig = await this.executePreRequestScript(processedConfig)
      }
      
      // 2. 参数格式转换
      const headers = this.paramTransformer.transformHeaders(processedConfig.headers || [])
      const params = this.paramTransformer.transformParams(processedConfig.params || [])
      
      // 3. 发起HTTP请求（复用现有@/service/request）
      const response = await request({
        url: processedConfig.url,
        method: processedConfig.method?.toLowerCase() as any,
        headers,
        params,
        data: processedConfig.body,
        timeout: processedConfig.timeout || 5000
      })

      // 4. 响应后脚本处理
      let responseData = response.data
      if (processedConfig.postResponseScript) {
        responseData = await this.executePostResponseScript(responseData, processedConfig)
      }

      // 5. 数据转换（保持现有逻辑）
      const transformedData = this.applyTransform(responseData, processedConfig.transform)

      return {
        success: true,
        data: transformedData,
        timestamp: Date.now(),
        sourceId: config.id,
        metadata: { responseTime: Date.now() - startTime }
      }
    } catch (error: any) {
      return this.createErrorResult(config.id, 'HTTP_ERROR', error.message)
    }
  }
}
```

#### 脚本使用示例

**preRequestScript示例**:
```javascript
// 动态添加时间戳头
config.headers.push({
  key: 'X-Timestamp', 
  value: Date.now().toString(),
  enabled: true
})

// 修改URL参数
config.url = config.url + '?requestId=' + Math.random().toString(36)

return config
```

**postResponseScript示例**:
```javascript
// 响应数据格式化
if (responseData.code === 200) {
  return {
    success: true,
    data: responseData.data,
    timestamp: Date.now()
  }
}

throw new Error('API响应错误: ' + responseData.message)
```

### 3. 实施方案总结

**核心特性**:
- 🎯 **职责分离** - HttpExecutor只处理静态配置执行  
- 📝 **脚本集成** - preRequest调整配置，postResponse修改结果
- 🔄 **格式转换** - HttpHeader[]/HttpParam[] → Record<string, any>
- 🔙 **向下兼容** - 支持现有简单配置格式
- ⚡ **高性能** - 复用现有@/service/request和ScriptEngine

**实施优先级**:
- **阶段1 (2天)**: ParameterTransformer + 脚本处理 + HttpExecutor增强
- **阶段2 (1天)**: 向下兼容测试 + 集成验证

## 🚀 性能优化设计

### 动态配置更新性能问题

**核心矛盾**:
- 📏 **配置庞大** - UnifiedDataConfig结构复杂
- 🎯 **变化微小** - 只是HTTP参数中的一个值（如deviceId）
- 🔄 **外部驱动** - 动态值跟随用户选择变化
- ⚡ **效率瓶颈** - 每次重新生成整个配置成本高

### 基于现有架构的优化方案

**现有基础设施优势**:
- ✅ **DataWarehouse** - 预留DynamicParameterStorage接口
- ✅ **ConfigEventBus** - 完整配置变更事件系统  
- ✅ **ConfigurationManager** - 配置模板和验证基础

**优化策略**:
- 🎯 **配置模板与动态值分离** - 模板缓存，只更新变化值
- 🔔 **订阅机制** - 监听动态参数变化，触发增量更新
- ⚡ **批量处理** - 合并多个参数变化，减少更新次数

### 性能优化架构设计

#### 扩展现有接口

```typescript
// 扩展DataWarehouse的动态参数存储
interface EnhancedDynamicParameterStorage extends DynamicParameterStorage {
  name: string
  value: any
  type: 'string' | 'number' | 'boolean' | 'object' | 'array'
  scope: 'global' | 'component' | 'session'
  // 🆕 订阅功能
  subscribers: Set<(oldValue: any, newValue: any) => void>
  dependentConfigs: Set<string>
}

// 扩展ConfigEventBus事件类型
export type ConfigEventType = 
  | 'config-changed'
  | 'data-source-changed'
  | 'dynamic-parameter-changed'  // 🆕 新增

// 配置模板变更事件
interface ConfigTemplateChangeEvent extends ConfigChangeEvent {
  changeType: 'template' | 'dynamic-value'
  dynamicParameterName?: string
  templateId?: string
}
```

#### 性能优化效果

| 传统方案 | 优化方案 | 性能提升 |
|---------|----------|----------|
| 重新生成整个配置 | 只更新变化值 | **10-100倍** |
| 全量配置对比 | 精确字段更新 | **5-20倍** |
| 无关变化也触发 | 只订阅相关参数 | **避免90%无效更新** |

### 核心架构增强要点

#### DataWarehouse订阅机制增强

```typescript
class EnhancedDataWarehouse {
  /**
   * 订阅动态参数变化
   * @param parameterName 参数名
   * @param callback 变化回调
   */
  subscribeDynamicParameter(
    parameterName: string, 
    callback: (oldValue: any, newValue: any) => void
  ): string {
    // 获取或创建动态参数存储
    let param = this.parameterStorage.get(parameterName)
    if (!param) {
      param = {
        name: parameterName,
        value: undefined,
        type: 'string',
        scope: 'global',
        subscribers: new Set(),
        dependentConfigs: new Set()
      }
      this.parameterStorage.set(parameterName, param)
    }
    
    param.subscribers.add(callback)
    return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
  
  /**
   * 更新动态参数值并触发订阅回调
   */
  updateDynamicParameter(parameterName: string, newValue: any): void {
    const param = this.parameterStorage.get(parameterName)
    if (!param) return
    
    const oldValue = param.value
    param.value = newValue
    
    // 触发所有订阅者
    param.subscribers.forEach(callback => {
      try {
        callback(oldValue, newValue)
      } catch (error) {
        console.error(`动态参数回调执行失败: ${parameterName}`, error)
      }
    })
  }
  
  /**
   * 批量获取动态参数值
   */
  getDynamicParameters(parameterNames: string[]): Record<string, any> {
    const result: Record<string, any> = {}
    parameterNames.forEach(name => {
      const param = this.parameterStorage.get(name)
      result[name] = param ? param.value : undefined
    })
    return result
  }
}
```

#### ConfigurationManager依赖分析增强

```typescript
class ConfigurationManager {
  /**
   * 分析配置模板的动态参数依赖
   */
  analyzeDynamicDependencies(template: ConfigurationTemplate): string[] {
    const dependencies = new Set<string>()
    this.extractPlaceholders(template.configuration, dependencies)
    return Array.from(dependencies)
  }
  
  /**
   * 递归提取{{paramName}}占位符
   */
  private extractPlaceholders(obj: any, dependencies: Set<string>): void {
    if (typeof obj === 'string') {
      const matches = obj.match(/\{\{([^}]+)\}\}/g)
      if (matches) {
        matches.forEach(match => {
          const paramName = match.replace(/[{}]/g, '')
          dependencies.add(paramName)
        })
      }
    } else if (Array.isArray(obj)) {
      obj.forEach(item => this.extractPlaceholders(item, dependencies))
    } else if (typeof obj === 'object' && obj !== null) {
      Object.values(obj).forEach(value => this.extractPlaceholders(value, dependencies))
    }
  }
}
```

### 优化工作流程示例

#### 配置模板设置
```typescript
// 使用占位符的HTTP配置模板
const httpTemplate = {
  id: 'device-status-api',
  configuration: {
    dataSources: [{
      item: {
        type: 'http',
        config: {
          url: '/api/device/{{currentDeviceId}}/status',
          method: 'GET',
          headers: [
            {key: 'Authorization', value: '{{authToken}}', isDynamic: true, variableName: 'authToken'},
            {key: 'Content-Type', value: 'application/json', isDynamic: false}
          ]
        }
      }
    }]
  }
}

// 分析动态参数依赖
const dependencies = configManager.analyzeDynamicDependencies(httpTemplate)
// 结果: ['currentDeviceId', 'authToken']
```

#### 建立订阅关系
```typescript
// 订阅动态参数变化
dependencies.forEach(paramName => {
  dataWarehouse.subscribeDynamicParameter(paramName, (oldValue, newValue) => {
    // 触发配置更新事件
    configEventBus.emitConfigChange({
      componentId: 'device-status-component',
      section: 'dataSource',
      changeType: 'dynamic-value',
      dynamicParameterName: paramName,
      oldConfig: { [paramName]: oldValue },
      newConfig: { [paramName]: newValue }
    })
  })
})
```

#### 增量更新处理
```typescript
// 处理动态参数变化
configEventBus.onConfigChange('dynamic-parameter-changed', async (event) => {
  // 1. 获取模板（缓存）
  const template = configManager.getTemplate('device-status-api')
  
  // 2. 批量获取当前所有动态值
  const currentValues = dataWarehouse.getDynamicParameters(dependencies)
  
  // 3. 合并生成静态配置
  const staticConfig = mergeTemplateWithValues(template, currentValues)
  
  // 4. 执行HTTP请求（配置已静态化）
  const executor = new EnhancedHttpExecutor()
  const result = await executor.execute(staticConfig)
  
  // 5. 存储结果
  dataWarehouse.storeComponentData('device-status-component', result.data)
})
```

#### 外部触发更新
```typescript
// 用户选择设备时
function onDeviceChange(deviceId: string) {
  // 只需更新一个参数，自动触发整个链式反应
  dataWarehouse.updateDynamicParameter('currentDeviceId', deviceId)
}

// 链式反应: 参数更新 → 订阅回调 → 事件发送 → 增量合并 → 执行器调用 → 结果存储
```

### 性能优势对比

**传统方案**:
```typescript
// ❌ 重新生成整个配置（耗时）
function traditionalUpdate(deviceId: string) {
  const bigConfig = generateEntireConfig(deviceId)
  executor.execute(bigConfig)
}
```

**优化方案**:
```typescript
// ✅ 只更新变化参数（高效）
function optimizedUpdate(deviceId: string) {
  dataWarehouse.updateDynamicParameter('currentDeviceId', deviceId)
  // 订阅机制自动处理后续流程
}
```

**核心优势**:
- 🎯 **精确更新** - 只处理变化的动态参数
- 🏗️ **架构复用** - 利用现有DataWarehouse、ConfigEventBus、ConfigurationManager
- ⚡ **高性能** - 模板缓存、批量获取、增量合并
- 🔧 **低侵入** - 基于预留接口扩展，不破坏现有功能

## 📋 实施计划

### 已完成部分

#### 类型系统扩展 ✅

**更新位置**: `src/core/data-architecture/types/enhanced-types.ts`

1. **HttpHeader接口扩展完成**:
```typescript
export interface HttpHeader {
  key: string
  value: string                    // 静态时为实际值，动态时为示例值
  enabled: boolean
  isDynamic: boolean              // 改为必填
  dataType: 'string' | 'number' | 'boolean' | 'json'  // 🆕 新增
  variableName: string            // 🆕 自动生成（格式：http_${key}）
  description?: string            // 🆕 参数说明
}
```

2. **HttpParam接口扩展完成**:
```typescript  
export interface HttpParam {
  key: string
  value: string                    
  enabled: boolean
  isDynamic: boolean              
  dataType: 'string' | 'number' | 'boolean' | 'json'  
  variableName: string            
  description?: string            
}
```

3. **UnifiedDataExecutor.ts集成完成**:
   - ✅ 删除重复的HttpParam定义
   - ✅ 导入正确的类型
   - ✅ 更新HTTP配置使用数组类型

### 待实施任务

#### 阶段1: HttpExecutor增强 (2天)
- [ ] ParameterTransformer实现
- [ ] preRequestScript脚本集成
- [ ] postResponseScript脚本集成
- [ ] 向下兼容支持

#### 阶段2: 性能优化 (2天)
- [ ] DataWarehouse订阅机制扩展
- [ ] ConfigEventBus动态参数事件支持
- [ ] ConfigurationManager依赖分析功能
- [ ] 增量更新工作流程

#### 阶段3: 系统集成测试 (1天)
- [ ] 端到端功能测试
- [ ] 性能优化验证
- [ ] 文档更新

## 📱 HTTP配置UI表单设计

### UI设计概述

**核心目标**: 为HTTP数据源配置设计用户友好的可视化表单，支持动态参数、脚本处理和实时预览

**设计约束**:
- 集成到现有ConfigurationPanel的dataSource标签页
- 右侧面板空间限制（300-400px宽度）
- 遵循Naive UI设计规范和主题系统

### 5个子标签页架构

基于技术架构，HTTP配置分为5个功能模块：

```
dataSource 标签页
├── HTTP配置表单 (HttpDataSourceConfigForm.vue)
    ├── 1️⃣ 基础 (HttpBasicConfig.vue)
    │   ├── URL配置（支持{{变量}}占位符）
    │   ├── HTTP方法选择
    │   ├── 超时设置
    │   └── 请求体配置（POST/PUT显示）
    ├── 2️⃣ 请求头 (HttpHeadersConfig.vue)
    │   ├── 动态列表管理
    │   ├── 静态/动态参数切换
    │   ├── 数据类型配置
    │   └── 常用请求头模板
    ├── 3️⃣ 参数 (HttpParamsConfig.vue)
    │   ├── 查询参数 (?key=value)
    │   ├── 路径参数 (/api/{id})
    │   └── 动态参数配置
    ├── 4️⃣ 请求脚本 (HttpRequestScriptConfig.vue)
    │   ├── preRequestScript编辑器
    │   ├── 脚本示例和模板
    │   └── 语法高亮和验证
    └── 5️⃣ 响应脚本 (HttpResponseScriptConfig.vue)
        ├── postResponseScript编辑器
        ├── 脚本测试功能
        └── 响应预览
```

### 关键UI设计要点

#### 1. 空间优化设计

**垂直布局策略**:
- 每个子标签页高度200-550px
- 支持垂直滚动
- 紧凑表单样式，label上置
- 动态高度适配内容

#### 2. 动态参数交互

**静态/动态切换**:
```vue
<!-- 动态参数开关设计 -->
<n-button 
  size="small"
  :type="header.isDynamic ? 'primary' : 'default'"
  @click="toggleDynamic(header)"
  style="width: 60px;"
>
  {{header.isDynamic ? '动态' : '静态'}}
</n-button>

<!-- 动态参数配置展开区域 -->
<div v-if="header.isDynamic" class="dynamic-config">
  <n-space size="small">
    <n-select
      v-model:value="header.dataType"
      :options="dataTypeOptions"
      style="width: 100px;"
    />
    <n-input
      v-model:value="header.description"
      placeholder="参数描述"
      style="flex: 1;"
    />
  </n-space>
</div>
```

#### 3. 脚本编辑器集成

**增强功能**:
- 语法高亮（JavaScript）
- 代码示例一键插入
- 脚本测试和验证
- 错误提示友好显示

```vue
<template>
  <div class="script-editor-container">
    <SimpleScriptEditor
      v-model:value="script"
      :height="200"
      language="javascript"
      :placeholder="scriptTemplate"
    />
    
    <!-- 示例代码折叠面板 -->
    <n-collapse size="small" class="script-examples">
      <n-collapse-item title="常用示例">
        <div v-for="example in scriptExamples" class="example-item">
          <div class="example-header">
            <span>{{ example.title }}</span>
            <n-button size="tiny" @click="insertExample(example.code)">
              插入
            </n-button>
          </div>
          <n-code :code="example.code" language="javascript" />
        </div>
      </n-collapse-item>
    </n-collapse>
  </div>
</template>
```

#### 4. 数据结构设计

**完整HTTP配置数据结构**:
```typescript
interface HttpDataSourceConfig {
  // 基础配置
  url: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'
  timeout: number
  body?: string

  // 请求头配置（与技术架构一致）
  headers: HttpHeader[]

  // 参数配置  
  params: HttpParam[]

  // 脚本配置
  preRequestScript?: string
  postResponseScript?: string
}
```

### ConfigurationPanel集成方案

**无缝集成现有系统**:

```typescript
// ConfigurationPanel.vue 数据源标签页
<template v-else-if="layer.name === 'dataSource'">
  <!-- 检测HTTP配置类型 -->
  <HttpDataSourceConfigForm
    v-if="isHttpDataSource"
    v-model="dataSourceConfig"
    :data-sources="componentDataSources"
    :selected-widget-id="selectedWidget?.id"
    :component-id="selectedWidget?.id"
    :component-type="selectedWidget?.type"
    @request-current-data="handleCurrentDataRequest"
  />
  
  <!-- 原有数据源配置组件 -->
  <component v-else :is="layer.component" ... />
</template>
```

### 交互体验优化

#### 智能化功能
- **常用请求头模板**: Authorization、Content-Type、Accept等
- **URL格式验证**: 实时检查URL有效性
- **动态参数名称生成**: 自动生成http_${key}格式
- **脚本语法检查**: JavaScript语法实时验证
- **配置预览**: 实时显示最终HTTP请求配置

#### 响应式适配
```css
/* 紧凑空间优化 */
.http-config-container {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.http-config-tabs {
  flex: 1;
  overflow: hidden;
}

.http-config-tabs :deep(.n-tabs-content) {
  height: calc(100% - 36px);
  overflow-y: auto;
  padding: 8px;
}

/* 动态参数视觉指示 */
.dynamic-indicator::after {
  content: '{{}}';
  color: var(--primary-color);
  font-size: 10px;
}
```

### 实施优先级整合

#### Phase 1: 基础框架 (1天)
- HttpDataSourceConfigForm.vue 主组件
- HttpBasicConfig.vue 基础配置
- ConfigurationPanel集成点

#### Phase 2: 动态参数系统 (1.5天)
- HttpHeadersConfig.vue 请求头配置
- HttpParamsConfig.vue 参数配置
- 静态/动态切换逻辑

#### Phase 3: 脚本编辑器 (1天)
- HttpRequestScriptConfig.vue 请求脚本
- HttpResponseScriptConfig.vue 响应脚本
- 脚本测试和验证

#### Phase 4: 集成优化 (0.5天)
- 配置验证和错误处理
- UI优化和响应式调整
- 与HttpExecutor数据交互测试

### 质量保证

**测试策略**:
- **功能测试**: HTTP配置场景、动态参数解析、脚本执行
- **UI测试**: 响应式布局、主题适配、用户交互流程
- **集成测试**: ConfigurationPanel集成、数据持久化、执行器对接

### 交付清单

**核心组件** (6个):
- HttpDataSourceConfigForm.vue (主组件)
- HttpBasicConfig.vue (基础配置)
- HttpHeadersConfig.vue (请求头)
- HttpParamsConfig.vue (参数)
- HttpRequestScriptConfig.vue (请求脚本)
- HttpResponseScriptConfig.vue (响应脚本)

**支持文件**:
- http-config-utils.ts (工具函数)
- http-config-templates.ts (模板和示例)
- http-config-validators.ts (验证规则)
- http-config-styles.css (专用样式)

---

## 📋 详细开发计划

### 分阶段实施方案

| 阶段 | 内容 | 预估时间 | 状态 | 关键交付物 |
|------|------|---------|------|-----------|
| **Phase 1** | 类型系统扩展 + HttpExecutor增强 | 3天 | ⏳ | 增强的HTTP执行器 |
| **Phase 2** | 性能优化机制实现 | 2天 | ⏳ | 订阅式动态参数系统 |
| **Phase 3** | UI表单组件开发 | 3天 | ⏳ | 5标签页HTTP配置界面 |
| **Phase 4** | Card2.1映射系统集成 | 2天 | ⏳ | 双盲映射组件 |
| **Phase 5** | 系统集成测试 + 优化 | 1天 | ⏳ | 完整可用系统 |
| **总计** | **完整HTTP配置系统** | **11天** | | **生产就绪系统** |

### 📋 下一步行动项

#### 立即可开始的任务
1. **类型系统扩展** - 修改 `src/core/data-architecture/types/enhanced-types.ts`
2. **HttpExecutor增强** - 实现 ParameterTransformer 和脚本处理系统
3. **UI组件开发** - 创建 5 个子标签页组件

#### 依赖性任务
1. **性能优化** - 需要 HttpExecutor 基础完成后开始
2. **Card2.1集成** - 需要类型系统和UI组件完成后开始
3. **端到端测试** - 需要所有核心功能完成后开始

#### 关键决策点
- **Day 3**: HttpExecutor 是否满足脚本执行需求？
- **Day 8**: UI 配置界面是否满足用户体验要求？  
- **Day 10**: Card2.1 映射是否能正确响应属性变化？

## 🔗 Card2.1架构集成：组件属性映射支持

### Card2.1组件系统调整

为了支持映射组件方案，需要对现有Card2.1组件系统进行以下扩展：

#### 1. ComponentDefinition接口扩展

```typescript
// 在 src/card2.1/core/types.ts 中扩展
export interface ComponentDefinition {
  // ... 现有属性 ...
  
  // 🆕 HTTP参数映射支持
  httpParameterMapping?: {
    /** 声明组件哪些属性可以用于HTTP参数映射 */
    mappableProperties: Array<{
      propertyName: string      // 属性名称 (如: deviceId)
      propertyPath: string      // 属性路径 (如: config.deviceId)
      dataType: 'string' | 'number' | 'boolean' | 'object'
      displayName: string       // 显示名称 (如: "设备ID")
      description?: string      // 属性说明
      mappingHint?: string      // 映射提示 (如: "用于API请求中的设备标识")
      isRecommended?: boolean   // 是否推荐映射
      group?: string            // 属性分组
    }>
    
    /** 映射能力声明 */
    capability?: {
      supportAutoMapping: boolean        // 是否支持自动映射
      maxMappingCount: number           // 最大映射数量限制
      supportedMappingTypes: Array<'direct' | 'computed' | 'template'>
    }
  }
}
```

#### 2. 属性暴露系统增强

```typescript
// 在 src/card2.1/core/property-exposure.ts 中扩展
export interface ListenableProperty {
  // ... 现有属性 ...
  
  // 🆕 HTTP映射支持标记
  httpMappingSupported?: boolean        // 是否支持HTTP参数映射
  httpMappingType?: 'url' | 'header' | 'query' | 'body'  // 建议映射到的HTTP部分
  httpMappingHint?: string             // 映射提示文本
  httpMappingPriority?: number         // 映射优先级 (1-10, 数字越大优先级越高)
}

// 🆕 HTTP参数映射专用属性模板
export const HttpMappingProperties = {
  deviceId: createProperty('deviceId', '设备ID', 'string', {
    description: '设备的唯一标识符',
    isCore: true,
    group: '设备',
    httpMappingSupported: true,
    httpMappingType: 'url',
    httpMappingHint: '通常映射到API URL中的{deviceId}参数',
    httpMappingPriority: 9,
    example: 'device_001'
  }),

  apiKey: createProperty('apiKey', 'API密钥', 'string', {
    description: 'API访问密钥',
    group: '认证',
    httpMappingSupported: true,
    httpMappingType: 'header',
    httpMappingHint: '映射到Authorization头部',
    httpMappingPriority: 8,
    example: 'sk-abc123...'
  }),

  tenantId: createProperty('tenantId', '租户ID', 'string', {
    description: '多租户环境下的租户标识',
    group: '租户',
    httpMappingSupported: true,
    httpMappingType: 'query',
    httpMappingHint: '映射到查询参数tenant',
    httpMappingPriority: 7,
    example: 'tenant_001'
  })
}
```

#### 3. HTTP参数映射注册系统

```typescript
// 新文件: src/card2.1/core/http-parameter-mapping.ts

// HTTP参数声明
export interface HttpParameterDeclaration {
  parameterName: string          // HTTP参数名
  parameterType: 'url' | 'header' | 'query' | 'body'
  dataType: 'string' | 'number' | 'boolean' | 'json'
  displayName: string           // 用户可见的参数名称
  description?: string          // 参数说明
  isDynamic: boolean           // 是否需要动态映射
  defaultValue?: any           // 默认值
  placeholder?: string         // 占位符示例 (如: {{deviceId}})
}

class HttpParameterMappingRegistry {
  // HTTP数据源参数声明注册表
  private httpDataSourceRegistry = new Map<string, HttpDataSourceMappingDeclaration>()
  
  // 映射关系存储
  private mappingRelationships = new Map<string, ComponentHttpParameterMapping>()

  /**
   * 获取组件可映射的属性列表
   * 直接从property-exposure系统获取支持HTTP映射的属性
   */
  getComponentMappableProperties(componentId: string, componentType: string) {
    const allProperties = propertyExposureRegistry.getListenableProperties(componentType)
    
    // 筛选支持HTTP映射的属性
    const mappableProperties = allProperties.filter(prop => 
      prop.httpMappingSupported === true
    )

    // 按优先级排序
    mappableProperties.sort((a, b) => 
      (b.httpMappingPriority || 0) - (a.httpMappingPriority || 0)
    )

    return mappableProperties.map(prop => ({
      propertyName: prop.name,
      propertyPath: prop.name,
      displayName: prop.label,
      description: prop.description,
      dataType: prop.type,
      mappingHint: prop.httpMappingHint,
      isRecommended: (prop.httpMappingPriority || 0) >= 8,
      group: prop.group
    }))
  }

  /**
   * 创建映射关系
   */
  createMapping(
    componentId: string,
    componentProperty: string,
    dataSourceKey: string,
    httpParameter: string,
    mappingType: 'direct' | 'computed' | 'template' = 'direct'
  ) {
    // 创建映射关系并建立响应式绑定
    // 集成前面设计的ParameterMappingCoordinator逻辑
  }

  /**
   * 获取组件的完整映射配置 (供映射UI使用)
   */
  getComponentMappingConfiguration(componentId: string, componentType: string) {
    return {
      // 组件可映射属性
      mappableProperties: this.getComponentMappableProperties(componentId, componentType),
      
      // HTTP数据源可映射参数  
      httpParameters: this.getHttpDataSourceMappableParameters(componentId),
      
      // 当前映射关系
      currentMappings: this.mappingRelationships.get(componentId),
      
      // HTTP配置信息
      httpDataSource: this.httpDataSourceRegistry.get(componentId)
    }
  }
}

// 创建全局实例
export const httpParameterMappingRegistry = new HttpParameterMappingRegistry()
```

#### 4. 组件定义示例改造

```typescript
// 改造示例: dual-data-display组件定义
const dualDataDisplayDefinition: ComponentDefinition = {
  // ... 现有属性 ...

  // 🆕 HTTP参数映射支持
  httpParameterMapping: {
    mappableProperties: [
      {
        propertyName: 'deviceId',
        propertyPath: 'config.deviceId',
        dataType: 'string',
        displayName: '设备ID',
        description: '当前组件监控的设备标识符',
        mappingHint: '映射到HTTP请求URL中的设备ID参数',
        isRecommended: true,
        group: '设备'
      },
      {
        propertyName: 'apiKey',
        propertyPath: 'config.apiKey',
        dataType: 'string', 
        displayName: 'API密钥',
        description: '访问设备API的认证密钥',
        mappingHint: '映射到Authorization请求头',
        isRecommended: true,
        group: '认证'
      }
    ],

    capability: {
      supportAutoMapping: true,
      maxMappingCount: 10,
      supportedMappingTypes: ['direct', 'template']
    }
  },

  // 扩展现有的属性暴露配置，添加HTTP映射标记
  interaction: {
    propertyExposure: {
      componentType: 'dual-data-display',
      componentName: '双数据源显示组件',
      listenableProperties: [
        {
          name: 'config.deviceId',
          label: '设备ID',
          type: 'string',
          description: '设备标识符',
          group: '设备',
          defaultValue: 'device_001',
          // 🆕 HTTP映射支持
          httpMappingSupported: true,
          httpMappingType: 'url',
          httpMappingHint: '映射到API路径参数',
          httpMappingPriority: 9
        }
      ]
    }
  }
}
```

### Card2.1集成优势

1. **复用现有系统** - 扩展现有 `property-exposure` 系统，不重新发明轮子
2. **渐进式增强** - 对现有 `ComponentDefinition` 进行扩展，保持向后兼容  
3. **标准化接口** - 使用统一的注册和查询接口，减少学习成本
4. **自动化注册** - 从组件定义中自动提取映射信息，减少手动配置
5. **降低复杂度** - 通过标准化的属性声明和映射机制，简化开发流程

### 双盲映射工作流程

1. **组件侧声明** - 组件通过 `httpParameterMapping.mappableProperties` 声明可映射属性
2. **数据源侧声明** - HTTP数据源通过参数配置声明需要映射的动态参数  
3. **映射UI连接** - 用户在映射界面中建立属性与参数的连接关系
4. **响应式绑定** - 系统自动建立属性变化的监听和HTTP配置更新机制
5. **实例级隔离** - 通过组件ID确保不同实例的映射配置完全独立

---

---

## 📊 完整实施计划总览

| 阶段 | 内容 | 预估时间 | 依赖关系 | 交付物 |
|------|------|---------|----------|--------|
| **Phase 1** | 类型系统扩展 + HttpExecutor增强 | 3天 | 无 | 增强的HTTP执行器 |
| **Phase 2** | 性能优化机制实现 | 2天 | Phase 1 | 订阅式动态参数系统 |
| **Phase 3** | UI表单组件开发 | 3天 | Phase 1 | 5标签页HTTP配置界面 |
| **Phase 4** | Card2.1映射系统集成 | 2天 | Phase 1, 3 | 双盲映射组件 |
| **Phase 5** | 系统集成测试 + 优化 | 1天 | 全部 | 完整可用系统 |
| **总计** | **完整HTTP配置系统** | **11天** | - | **生产就绪系统** |

### 关键里程碑
- **Day 3**: HttpExecutor增强完成，支持脚本处理
- **Day 5**: 性能优化机制就绪，支持大规模配置
- **Day 8**: UI配置界面完成，用户可以完整配置HTTP
- **Day 10**: Card2.1映射完成，组件属性可绑定HTTP参数
- **Day 11**: 系统完全集成，端到端可用

### 风险控制
- **技术风险**: 基于现有架构扩展，复用成熟组件，风险较低
- **集成风险**: 分阶段实施，每个阶段独立可测试
- **用户体验风险**: 通过5标签页分层设计，降低配置复杂度

---

## 🎯 系统核心特性总结

### 技术架构特性
- ✅ **职责分离**: HttpExecutor只处理静态配置，动态解析由上层处理
- ✅ **脚本集成**: preRequestScript调整配置，postResponseScript处理响应
- ✅ **性能优化**: 基于DataWarehouse订阅机制，避免大配置重新生成
- ✅ **向下兼容**: 支持现有简单HTTP配置格式

### 用户界面特性
- ✅ **分层配置**: 5标签页设计（基础/请求头/参数/请求脚本/响应脚本）
- ✅ **动态参数**: 静态/动态参数一键切换，支持数据类型转换
- ✅ **脚本编辑**: 集成SimpleScriptEditor，支持语法高亮和示例
- ✅ **实时预览**: 配置变化实时生成HTTP请求预览

### 组件集成特性  
- ✅ **双盲映射**: 组件属性和HTTP参数通过映射组件连接，完全解耦
- ✅ **响应式绑定**: 组件属性变化自动触发HTTP配置更新
- ✅ **实例隔离**: 不同组件实例的映射配置完全独立
- ✅ **标准化**: 基于Card2.1属性暴露系统，统一映射机制

---

**📄 文档状态**: HTTP配置系统完整需求设计已完成  
**🗓️ 创建时间**: 2025-08-29  
**🔄 最后更新**: 2025-08-29  
**⏱️ 预计实施周期**: 11天（技术架构 + UI表单 + 组件映射 + 性能优化 + 集成测试）  
**👥 目标团队**: 前端架构师、UI开发工程师、组件开发工程师  
**🎯 交付目标**: 生产就绪的HTTP配置系统，支持动态参数映射和企业级性能要求