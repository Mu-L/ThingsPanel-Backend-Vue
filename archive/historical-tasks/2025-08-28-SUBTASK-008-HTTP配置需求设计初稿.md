# SUBTASK-008 HTTP配置需求沟通和设计 - 基于现有架构的正确设计

**创建时间**: 2025-08-28  
**任务ID**: SUBTASK-008  
**所属大任务**: HTTP动态参数与高级配置系统 (TASK-2025-08-28-HTTP-DYNAMIC-SYSTEM-V1)  
**执行时间**: 重新设计中  
**文档状态**: 基于深度架构理解的重新设计版本

---

## 📊 现有架构深度分析

### 🏗️ 核心架构理解

通过深入代码分析，发现项目采用**配置驱动的响应式数据执行架构**：

```
配置变更 → ConfigEventBus → UnifiedDataExecutor → DataWarehouse → 组件更新
     ↑                                ↓
 用户操作                        实际HTTP请求
```

### ✅ 已有基础设施分析

**1. 配置事件驱动系统** `(ConfigEventBus.ts)`
```typescript
// 配置变更会触发事件
configEventBus.emitConfigChange({
  componentId: widgetId,
  section: 'dataSource', 
  newConfig: httpConfig,  // HTTP配置在这里
  timestamp: Date.now(),
  source: 'user'
})
```

**2. 统一数据执行器** `(UnifiedDataExecutor.ts)`
```typescript
// 已有完整的HttpExecutor实现
class HttpExecutor implements DataSourceExecutor {
  async execute(config: UnifiedDataConfig): Promise<UnifiedDataResult> {
    const { url, method, headers, params, body } = config.config
    const response = await request({ url, method, headers, params, data: body })
    return { success: true, data: response.data, timestamp: Date.now(), sourceId: config.id }
  }
}
```

**3. 数据仓库缓存系统** `(DataWarehouse.ts)`
```typescript
// 配置变更时自动清理缓存，触发重新执行
simpleDataBridge.clearComponentCache(widgetId)
```

**4. 响应式数据绑定** `(Card2.1 data-binding系统)`
```typescript
// 支持多种触发器：定时器、WebSocket、事件、手动
const binding = new ReactiveDataBindingImpl(id, componentId, pipeline, triggers, onDataChange)
```

### ❌ 关键缺失

1. **HTTP配置格式不匹配** - 需要适配UnifiedDataConfig接口
2. **动态参数机制缺失** - 没有运行时参数注入机制  
3. **配置界面未集成** - HttpConfigForm.vue未启用(available: false)
4. **参数变量系统缺失** - 缺少变量定义和解析机制

---

## 🎯 基于现有架构的HTTP配置设计

### 💡 核心设计思想

**动态参数的本质**: 不是在配置阶段获取值，而是在**配置中定义变量占位符，在执行时动态解析**

```typescript
// 配置阶段：定义变量占位符
httpConfig = {
  url: "http://api.example.com/device/data",
  method: "POST",
  requestParams: [
    { key: "deviceId", value: "{{selectedDeviceId}}", isVariable: true },  // 变量
    { key: "dataType", value: "temperature", isVariable: false }            // 静态值
  ]
}

// 执行阶段：UnifiedDataExecutor调用时动态解析
// selectedDeviceId变量 → 从组件状态获取实际值 → "device_123"
// 最终请求: { deviceId: "device_123", dataType: "temperature" }
```

### 🏗️ 适配现有架构的设计

**1. HTTP配置数据结构** (适配UnifiedDataConfig)
```typescript
interface HttpDataSourceConfig extends UnifiedDataConfig {
  id: string
  type: 'http'
  name?: string
  enabled?: boolean
  config: {
    // 基础HTTP配置
    url: string
    method: 'GET' | 'POST' | 'PUT' | 'DELETE'
    timeout?: number
    
    // Headers配置 (适配现有格式)
    headers?: Record<string, string>  // 现有执行器期望的格式
    
    // 参数配置 (适配现有格式) 
    params?: Record<string, any>      // GET请求参数
    body?: any                        // POST/PUT/DELETE请求体
    
    // 🆕 变量定义和解析配置
    variables?: VariableDefinition[]   // 变量定义列表
    variableResolver?: string         // 变量解析器脚本
  }
}

// 变量定义接口
interface VariableDefinition {
  name: string                      // 变量名，如 "selectedDeviceId"  
  source: VariableSource           // 变量来源
  defaultValue?: any               // 默认值
  description?: string             // 描述
}

// 变量来源定义  
interface VariableSource {
  type: 'component' | 'global' | 'computed' | 'script'
  path?: string                    // 数据路径，如 "props.deviceId"
  script?: string                  // 脚本计算
}
```

**2. 配置界面设计** (3个页签)
- **页签1: 基础配置** - URL、请求方式、超时设置
- **页签2: 请求参数** - Headers和Body参数统一配置
- **页签3: 变量管理** - 定义和管理动态变量

## 🔧 技术实现方案

### 1. 扩展UnifiedDataExecutor支持变量解析

在现有HttpExecutor基础上增加变量解析功能：

```typescript
class EnhancedHttpExecutor implements DataSourceExecutor {
  type = 'http'
  
  async execute(config: UnifiedDataConfig): Promise<UnifiedDataResult> {
    try {
      // 🆕 步骤1: 解析配置中的变量
      const resolvedConfig = await this.resolveVariables(config)
      
      // 步骤2: 使用现有逻辑执行HTTP请求
      const { url, method = 'GET', headers, params, body } = resolvedConfig.config
      const response = await request({
        url, method: method.toLowerCase() as any, headers, params, data: body
      })
      
      return {
        success: true,
        data: response.data,
        timestamp: Date.now(),
        sourceId: config.id
      }
    } catch (error: any) {
      return {
        success: false,
        error: error.message || '请求失败',
        timestamp: Date.now(),
        sourceId: config.id
      }
    }
  }
  
  /**
   * 🆕 解析配置中的变量占位符
   */
  private async resolveVariables(config: UnifiedDataConfig): Promise<UnifiedDataConfig> {
    const httpConfig = config.config
    const variables = httpConfig.variables || []
    
    // 构建变量值映射表
    const variableValues: Record<string, any> = {}
    for (const variable of variables) {
      variableValues[variable.name] = await this.resolveVariable(variable)
    }
    
    // 解析URL中的变量
    let resolvedUrl = httpConfig.url
    for (const [varName, varValue] of Object.entries(variableValues)) {
      resolvedUrl = resolvedUrl.replace(`{{${varName}}}`, String(varValue))
    }
    
    // 解析headers中的变量
    const resolvedHeaders: Record<string, string> = {}
    if (httpConfig.headers) {
      for (const [key, value] of Object.entries(httpConfig.headers)) {
        let resolvedValue = value
        for (const [varName, varValue] of Object.entries(variableValues)) {
          resolvedValue = resolvedValue.replace(`{{${varName}}}`, String(varValue))
        }
        resolvedHeaders[key] = resolvedValue
      }
    }
    
    // 解析params和body中的变量
    const resolvedParams = this.resolveObjectVariables(httpConfig.params, variableValues)
    const resolvedBody = this.resolveObjectVariables(httpConfig.body, variableValues)
    
    return {
      ...config,
      config: {
        ...httpConfig,
        url: resolvedUrl,
        headers: resolvedHeaders,
        params: resolvedParams,
        body: resolvedBody
      }
    }
  }
  
  /**
   * 解析单个变量的值
   */
  private async resolveVariable(variable: VariableDefinition): Promise<any> {
    try {
      switch (variable.source.type) {
        case 'component':
          // 从组件状态获取值
          return this.getComponentVariable(variable.source.path || '')
        
        case 'global': 
          // 从全局状态获取值
          return this.getGlobalVariable(variable.source.path || '')
        
        case 'computed':
          // 计算值
          return this.getComputedVariable(variable.source.path || '')
        
        case 'script':
          // 脚本执行
          return await this.executeScript(variable.source.script || '')
        
        default:
          return variable.defaultValue
      }
    } catch (error) {
      console.warn(`变量解析失败: ${variable.name}`, error)
      return variable.defaultValue
    }
  }
  
  private resolveObjectVariables(obj: any, variables: Record<string, any>): any {
    if (!obj) return obj
    
    let resolved = JSON.stringify(obj)
    for (const [varName, varValue] of Object.entries(variables)) {
      resolved = resolved.replace(new RegExp(`"{{${varName}}}"`, 'g'), JSON.stringify(varValue))
    }
    
    try {
      return JSON.parse(resolved)
    } catch {
      return obj
    }
  }
}
```

### 2. 变量获取实现

```typescript
/**
 * 变量值获取器 - 从现有系统获取变量值
 */
class VariableResolver {
  
  /**
   * 从组件状态获取变量
   */
  getComponentVariable(path: string, componentId?: string): any {
    // 方案1: 从DataWarehouse获取组件数据
    const componentData = dataWarehouse.getComponentData(componentId || 'current')
    return this.getValueByPath(componentData, path)
  }
  
  /**
   * 从全局状态获取变量 
   */
  getGlobalVariable(path: string): any {
    // 从各种Store获取全局状态
    if (path.startsWith('auth.')) {
      const authStore = useAuthStore()
      return this.getValueByPath(authStore, path.substring(5))
    }
    
    if (path.startsWith('theme.')) {
      const themeStore = useThemeStore()
      return this.getValueByPath(themeStore, path.substring(6))
    }
    
    // 其他全局状态...
    return null
  }
  
  /**
   * 获取计算值
   */
  getComputedVariable(path: string): any {
    const computedMap = {
      'currentTimestamp': () => Date.now(),
      'currentDate': () => new Date().toISOString(),
      'randomId': () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    }
    
    return computedMap[path]?.() || null
  }
  
  /**
   * 执行脚本获取值
   */
  async executeScript(script: string): Promise<any> {
    try {
      // 使用现有的脚本引擎
      const result = await defaultScriptEngine.execute(script, {
        // 提供脚本上下文
        currentTime: Date.now(),
        randomNumber: (min: number, max: number) => Math.random() * (max - min) + min
      })
      
      return result.success ? result.data : null
    } catch (error) {
      console.error('脚本执行失败:', error)
      return null
    }
  }
  
  /**
   * 按路径获取对象值
   */
  private getValueByPath(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj)
  }
}
```

### 3. 配置界面实现

**HttpConfigForm.vue 重构方案**：

```vue
<template>
  <n-tabs v-model:value="activeTab" type="card">
    <!-- 页签1: 基础配置 -->
    <n-tab-pane name="basic" :tab="$t('http.config.basic')">
      <n-form :model="httpConfig" label-placement="top">
        <n-form-item :label="$t('http.config.url')" required>
          <n-input v-model:value="httpConfig.url" placeholder="http://api.example.com" />
        </n-form-item>
        
        <n-form-item :label="$t('http.config.method')" required>
          <n-select v-model:value="httpConfig.method" :options="methodOptions" />
        </n-form-item>
        
        <n-form-item :label="$t('http.config.timeout')">
          <n-input-number v-model:value="httpConfig.timeout" :min="1000" :max="60000" />
        </n-form-item>
      </n-form>
    </n-tab-pane>
    
    <!-- 页签2: 请求参数 -->
    <n-tab-pane name="params" :tab="$t('http.config.params')">
      <n-space vertical>
        <!-- Headers配置 -->
        <n-card :title="$t('http.config.headers')" size="small">
          <template #header-extra>
            <n-button size="small" @click="addHeader">
              <template #icon><i-material-symbols:add /></template>
              {{ $t('common.add') }}
            </n-button>
          </template>
          
          <n-space vertical>
            <div v-for="(header, index) in headers" :key="index" class="param-row">
              <n-input v-model:value="header.key" placeholder="Header名称" />
              <n-input v-model:value="header.value" placeholder="值或{{变量名}}" />
              <n-button size="small" type="error" @click="removeHeader(index)">
                <template #icon><i-material-symbols:delete /></template>
              </n-button>
            </div>
          </n-space>
        </n-card>
        
        <!-- Body参数配置 -->
        <n-card :title="$t('http.config.body')" size="small">
          <!-- 类似Headers的实现 -->
        </n-card>
      </n-space>
    </n-tab-pane>
    
    <!-- 页签3: 变量管理 -->  
    <n-tab-pane name="variables" :tab="$t('http.config.variables')">
      <VariableManager v-model:variables="httpConfig.variables" />
    </n-tab-pane>
  </n-tabs>
</template>

<script setup lang="ts">
// 组件实现...
const activeTab = ref('basic')
const httpConfig = ref<HttpDataSourceConfig>({
  id: '',
  type: 'http',
  config: {
    url: '',
    method: 'GET',
    headers: {},
    params: {},
    variables: []
  }
})

// 配置变更时触发事件
watch(() => httpConfig.value, (newConfig) => {
  emit('update:modelValue', newConfig)
}, { deep: true })
</script>
```
```

## 📋 使用示例

### 实际配置示例

**场景**: 获取当前用户选中设备的实时温度数据

```typescript
// 1. 变量定义
const variables: VariableDefinition[] = [
  {
    name: 'selectedDeviceId',
    source: { type: 'component', path: 'props.deviceId' },
    defaultValue: 'default-device',
    description: '用户选中的设备ID'
  },
  {
    name: 'currentTimestamp', 
    source: { type: 'computed', path: 'currentTimestamp' },
    description: '当前时间戳'
  },
  {
    name: 'authToken',
    source: { type: 'global', path: 'auth.token' },
    description: '用户认证令牌'
  }
]

// 2. HTTP配置
const httpConfig: HttpDataSourceConfig = {
  id: 'device-temperature-api',
  type: 'http',
  config: {
    url: 'http://api.iot-platform.com/device/{{selectedDeviceId}}/data',
    method: 'POST',
    headers: {
      'Authorization': 'Bearer {{authToken}}',
      'Content-Type': 'application/json'
    },
    body: {
      dataType: 'temperature',
      timestamp: '{{currentTimestamp}}',
      deviceId: '{{selectedDeviceId}}'
    },
    variables
  }
}

// 3. 配置变更触发执行
configurationManager.updateConfiguration(componentId, 'dataSource', {
  type: 'http',
  config: httpConfig
})

// 4. 系统自动执行流程：
// ConfigEventBus发出事件 → EnhancedHttpExecutor解析变量 → 发送HTTP请求 → 返回数据
```

### 执行时的变量解析过程

```typescript
// 执行前的配置
url: 'http://api.iot-platform.com/device/{{selectedDeviceId}}/data'
body: { deviceId: '{{selectedDeviceId}}', timestamp: '{{currentTimestamp}}' }

// ↓ EnhancedHttpExecutor解析变量

// 执行时的实际配置  
url: 'http://api.iot-platform.com/device/device_123/data'
body: { deviceId: 'device_123', timestamp: 1693456789000 }

// ↓ 发送HTTP请求

// 实际发送的请求
POST http://api.iot-platform.com/device/device_123/data
Headers: {
  'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
  'Content-Type': 'application/json'
}
Body: {
  "deviceId": "device_123",
  "timestamp": 1693456789000,
  "dataType": "temperature"
}
```

---

## ✅ 实施计划

### SUBTASK-009: HTTP配置界面实现

**目标**: 实现HTTP配置的3页签界面

**技术要点**:
1. 重构现有HttpConfigForm.vue为3页签设计
2. 实现变量定义和管理界面
3. 集成到RawDataConfigModal中(设置available: true)

**验收标准**:
- [ ] 基础配置页签：URL、方法、超时配置
- [ ] 请求参数页签：Headers和Body参数配置，支持{{变量}}语法  
- [ ] 变量管理页签：变量定义、来源配置、默认值设置
- [ ] 配置变更正确触发ConfigEventBus事件

### SUBTASK-010: HTTP执行器增强

**目标**: 增强UnifiedDataExecutor支持变量解析

**技术要点**:
1. 扩展HttpExecutor类增加变量解析功能
2. 实现VariableResolver类，从现有Store系统获取变量值
3. 支持component/global/computed/script四种变量类型

**验收标准**:
- [ ] EnhancedHttpExecutor正确解析{{变量}}占位符
- [ ] 变量解析失败时使用默认值
- [ ] 与现有ConfigEventBus事件机制完全兼容
- [ ] 变量解析性能满足要求(< 100ms)

### SUBTASK-011: 系统集成测试

**目标**: 完整的端到端测试

**技术要点**:
1. 配置变更 → 事件发出 → 变量解析 → HTTP请求 → 数据更新的完整链路测试
2. 多种变量类型的综合测试
3. 错误处理和边界条件测试

**验收标准**:
- [ ] 配置界面修改能正确触发HTTP请求
- [ ] 变量值变化能触发HTTP请求重新执行
- [ ] 错误情况(网络失败、变量解析失败等)有合适处理
- [ ] 性能满足要求，无内存泄漏

### 2. HTTP执行器增强方案

```typescript
/**
 * 增强版HTTP执行器
 * 扩展UnifiedDataExecutor的HttpExecutor
 */
class EnhancedHttpExecutor implements DataSourceExecutor {
  private parameterResolver = new DynamicParameterResolver()
  private scriptExecutor = new ScriptExecutor()
  private requestCache = new Map<string, CachedResponse>()
  
  async execute(config: UnifiedDataConfig): Promise<UnifiedDataResult> {
    try {
      // 1. 执行请求前脚本处理
      const processedConfig = await this.executePreRequestScript(config)
      
      // 2. 解析动态参数
      const resolvedConfig = await this.resolveDynamicParameters(processedConfig)
      
      // 3. 检查缓存
      const cacheKey = this.generateCacheKey(resolvedConfig)
      if (this.shouldUseCache(resolvedConfig) && this.requestCache.has(cacheKey)) {
        return this.getCachedResponse(cacheKey)
      }
      
      // 4. 发送HTTP请求 (使用项目的request服务)
      const response = await this.sendHttpRequest(resolvedConfig)
      
      // 5. 缓存响应
      if (resolvedConfig.cache) {
        this.cacheResponse(cacheKey, response, resolvedConfig.cacheTime)
      }
      
      // 6. 执行请求后脚本处理
      const finalData = await this.executePostResponseScript(response, config)
      
      return {
        success: true,
        data: finalData,
        timestamp: Date.now(),
        sourceId: config.id,
        metadata: {
          responseTime: response.responseTime,
          fromCache: false,
          resolvedParams: this.getResolvedParamsSummary()
        }
      }
    } catch (error) {
      return this.handleExecutionError(error, config.id)
    }
  }
  
  /**
   * 使用项目request服务发送HTTP请求
   */
  private async sendHttpRequest(config: UnifiedDataConfig) {
    const { url, method, headers, requestParams } = config.config
    const { request } = await import('@/service/request')
    
    // 转换数组格式的headers和requestParams为对象格式
    const headerObj = this.arrayToObject(headers)
    const requestData = this.arrayToObject(requestParams)
    
    // 根据请求方法智能处理参数位置
    if (method.toUpperCase() === 'GET') {
      // GET请求：参数放URL
      return await request({
        url,
        method: method.toLowerCase() as any,
        headers: headerObj,
        params: requestData  // GET请求参数放params
      })
    } else {
      // POST/PUT/DELETE：参数放Body
      return await request({
        url,
        method: method.toLowerCase() as any,
        headers: headerObj,
        data: requestData  // 其他请求参数放data(body)
      })
    }
  }
  
  /**
   * 将数组格式的配置转换为对象格式
   * 处理动态参数和静态值
   */
  private arrayToObject(items: Array<{key: string, value: string, isDynamic: boolean, enabled: boolean}>, context: ParameterContext) {
    const result = {}
    items?.filter(item => item.enabled).forEach(item => {
      if (item.isDynamic) {
        // 动态参数：从context中解析获取实际值
        result[item.key] = this.parameterResolver.resolve(item.value, context)
      } else {
        // 静态值：直接使用
        result[item.key] = item.value
      }
    })
    return result
  }
}
```

### 3. RawDataConfigModal集成扩展

需要扩展的关键点：

```typescript
// 1. 启用HTTP选项
const inputMethods = [
  { label: 'JSON数据', value: 'json', available: true },
  { label: 'HTTP接口', value: 'http', available: true }, // 改为true
  { label: 'JavaScript脚本', value: 'script', available: true }
]

// 2. 扩展表单状态
const formState = reactive({
  // ...现有字段
  
  // HTTP扩展字段
  httpConfig: {
    url: '',
    method: 'GET',
    headers: [],
    requestParams: [],
    preRequestScript: '',
    postResponseScript: '',
    templateId: null,
    timeout: 5000,
    cache: false,
    cacheTime: 300
  } as HttpDataSourceConfig
})

// 3. 扩展getCurrentDataItem方法
const getCurrentDataItem = (): DataItem => {
  switch (formState.selectedMethod) {
    case 'http':
      return {
        type: 'http',
        config: formState.httpConfig
      }
    // ...其他cases
  }
}
```

### 4. 预制配置模板系统

```typescript
/**
 * HTTP配置模板管理器
 */
class HttpConfigTemplateManager {
  private templates: HttpConfigTemplate[] = [
    {
      id: 'restful-api-get',
      name: 'RESTful API (GET)',
      description: '标准RESTful API GET请求模板',
      category: 'RESTful',
      config: {
        method: 'GET',
        headers: [
          { key: 'Content-Type', value: 'application/json', isDynamic: false, enabled: true, description: '内容类型' },
          { key: 'Authorization', value: 'globalState.authToken', isDynamic: true, enabled: true, description: '认证令牌' }
        ],
        requestParams: [
          { key: 'page', value: '1', isDynamic: false, enabled: true, dataType: 'number', description: '页码' },
          { key: 'limit', value: '10', isDynamic: false, enabled: true, dataType: 'number', description: '每页数量' }
        ]
      },
      tags: ['RESTful', 'GET', '分页']
    },
    {
      id: 'iot-sensor-data',
      name: '物联网传感器数据',
      description: '获取设备传感器实时数据',
      category: '物联网',
      config: {
        method: 'GET',
        headers: [
          { key: 'Device-ID', value: 'componentData.deviceId', isDynamic: true, enabled: true, description: '设备ID' },
          { key: 'API-Key', value: 'environmentVars.apiKey', isDynamic: true, enabled: true, description: 'API密钥' }
        ],
        requestParams: [
          { key: 'timeRange', value: 'componentData.selectedTimeRange', isDynamic: true, enabled: true, dataType: 'string', description: '时间范围' },
          { key: 'dataType', value: 'temperature,humidity', isDynamic: false, enabled: true, dataType: 'string', description: '数据类型' }
        ],
        postResponseScript: `
// 处理传感器数据格式
if (data && data.sensors) {
  return data.sensors.map(sensor => ({
    id: sensor.device_id,
    temperature: sensor.temp_value,
    humidity: sensor.hum_value,
    timestamp: new Date(sensor.timestamp).getTime()
  }))
}
return data
        `
      },
      tags: ['物联网', '传感器', '实时数据']
    },
    {
      id: 'webhook-post',
      name: 'Webhook POST请求',
      description: '向第三方服务发送Webhook数据',
      category: '集成',
      config: {
        method: 'POST',
        headers: [
          { key: 'Content-Type', value: 'application/json', isDynamic: false, enabled: true, description: '内容类型' },
          { key: 'X-Webhook-Signature', value: 'computedValues.webhookSignature', isDynamic: true, enabled: true, description: 'Webhook签名' }
        ],
        requestParams: [
          { key: 'event', value: 'componentData.eventType', isDynamic: true, enabled: true, dataType: 'string', description: '事件类型' },
          { key: 'data', value: 'componentData.eventData', isDynamic: true, enabled: true, dataType: 'object', description: '事件数据' },
          { key: 'timestamp', value: 'systemVars.currentTimestamp', isDynamic: true, enabled: true, dataType: 'number', description: '时间戳' }
        ],
        preRequestScript: `
// 生成Webhook签名
const crypto = require('crypto')
const payload = JSON.stringify(context.requestBody)
const signature = crypto.createHmac('sha256', context.secret).update(payload).digest('hex')
context.webhookSignature = 'sha256=' + signature
        `
      },
      tags: ['Webhook', 'POST', '集成', '签名']
    }
  ]
  
  /**
   * 获取所有模板
   */
  getTemplates(): HttpConfigTemplate[] {
    return this.templates
  }
  
  /**
   * 按分类获取模板
   */
  getTemplatesByCategory(category: string): HttpConfigTemplate[] {
    return this.templates.filter(t => t.category === category)
  }
  
  /**
   * 应用模板到配置
   */
  applyTemplate(templateId: string, currentConfig?: Partial<HttpDataSourceConfig>): HttpDataSourceConfig {
    const template = this.templates.find(t => t.id === templateId)
    if (!template) {
      throw new Error(`模板不存在: ${templateId}`)
    }
    
    return {
      ...currentConfig,
      ...template.config,
      templateId
    } as HttpDataSourceConfig
  }
}
```

---

## 🚀 性能优化方案

### 1. 智能缓存机制

```typescript
interface CachedResponse {
  data: any
  timestamp: number
  expireTime: number
  requestHash: string
}

class HttpRequestCache {
  private cache = new Map<string, CachedResponse>()
  private maxCacheSize = 100
  
  /**
   * 生成缓存键
   */
  generateCacheKey(config: HttpDataSourceConfig): string {
    const key = JSON.stringify({
      url: config.url,
      method: config.method,
      headers: config.headers.filter(h => h.enabled),
      params: config.params.filter(p => p.enabled),
      body: config.body
    })
    return this.hashString(key)
  }
  
  /**
   * 检查是否应该使用缓存
   */
  shouldUseCache(config: HttpDataSourceConfig): boolean {
    return config.cache && config.method === 'GET'
  }
}
```

### 2. 防抖节流机制

```typescript
class HttpRequestDebouncer {
  private pendingRequests = new Map<string, Promise<any>>()
  private requestTimers = new Map<string, NodeJS.Timeout>()
  
  /**
   * 防抖执行HTTP请求
   */
  debounceRequest(key: string, executor: () => Promise<any>, delay = 300): Promise<any> {
    // 清除之前的定时器
    if (this.requestTimers.has(key)) {
      clearTimeout(this.requestTimers.get(key)!)
    }
    
    // 返回防抖的Promise
    return new Promise((resolve, reject) => {
      const timer = setTimeout(async () => {
        try {
          const result = await executor()
          resolve(result)
        } catch (error) {
          reject(error)
        } finally {
          this.requestTimers.delete(key)
        }
      }, delay)
      
      this.requestTimers.set(key, timer)
    })
  }
}
```

---

## 📋 优化后的动态参数设计优势

**✅ 设计优势**:
1. **界面清晰**: 勾选框明确标识动态/静态参数，无需解析复杂语法
2. **管理简单**: `isDynamic` 标识字段，避免正则表达式解析 `${param}` 语法  
3. **用户友好**: 动态参数时显示参数源选择器，提供可选参数列表
4. **性能优化**: 不传参数时不发送，避免无效请求参数
5. **扩展性好**: 易于添加新的参数源类型和验证逻辑

**🔧 核心实现逻辑**:
```typescript
// 处理参数时的逻辑
function processParameter(param: HttpParameter, context: ParameterContext) {
  if (!param.enabled) {
    return null // 未启用，不发送
  }
  
  if (param.isDynamic) {
    const value = parameterResolver.resolve(param.value, context)
    return value !== undefined ? { [param.key]: value } : null // 值为空时不发送
  } else {
    return { [param.key]: param.value } // 静态值直接使用
  }
}
```

---

## 📋 需求确认和澄清

### ✅ 已确认的需求

1. **URL动态参数支持**: ❌ **不需要** - URL不支持动态参数，避免数据获取不可控
5. **性能影响评估**: ✅ **需要防抖机制** - 参数值频繁变化时使用防抖避免过度请求
6. **RawDataConfigModal集成**: ❌ **暂不考虑** - 向后兼容问题后续处理
7. **预制模板系统**: ✅ **需要** - 通过文件引入配置对象数组，支持JSON导入功能，提供数据类型和示例
8. **测试和调试功能**: ❌ **暂时没有** - 先实现基础功能
9. **安全性考虑**: ✅ **使用现有script-engine** - 路径: `src/core/script-engine`
10. **国际化支持**: ⏳ **后续统一处理** - 不在当前任务范围

### ✅ 最终确认的需求

2. **请求参数动态配置**: ✅ **重点支持** - 统一的请求参数配置，系统智能处理放URL还是Body
3. **参数源数据获取时机**: ✅ **勾选"动态参数"时获取** - 支持默认值，表单必填验证  
4. **错误处理策略**: ✅ **获取失败使用默认值** - 配合表单验证确保完整性

### 🎯 动态参数优先级说明
- **请求参数 (requestParams)**: 🔥 **主要场景** - 重点支持，业务数据传输的核心，系统自动决定放URL(GET)还是Body(POST/PUT/DELETE)
- **Headers (请求头)**: 📋 **次要场景** - 顺便支持，主要用于认证和元数据
- **URL路径参数**: ❌ **不支持** - 避免动态URL导致的复杂性

### 📝 表单验证规则
- **必填字段**: URL、请求方式、所有已添加的参数项(除脚本外)
- **验证时机**: 表单校验通过后自动发送请求
- **参数完整性**: 添加参数项后必须填写完整(key、value、动态配置等)

---

## 🔧 动态参数管理系统设计

### 🎯 核心概念说明

**动态参数就是：配置HTTP请求时，某些参数值不是固定写死的，而是从其他地方获取的**

举个例子：
- ❌ **静态参数**: `deviceId: "device123"` (写死了)  
- ✅ **动态参数**: `deviceId: 从当前选中的设备获取` (灵活变化)

**界面交互**：每个参数行有一个"动态参数"勾选框
```
参数名: [deviceId     ] 参数值: [device123  ] [☐ 动态参数] [描述...]
参数名: [timestamp   ] 参数值: [选择参数源 ▼] [☑ 动态参数] [描述...]
```

### 🎯 动态参数数据源架构

基于项目现有的Store架构，动态参数来源分为四大类：

```typescript
/**
 * 动态参数数据源 - 简化说明
 */
interface DynamicParameterSources {
  // 📊 组件数据 (当前页面/组件的数据)
  componentData: {
    selectedDeviceId: string      // 当前选中的设备ID
    selectedTimeRange: string     // 当前选中的时间范围  
    chartType: string            // 图表类型
    filterConditions: any        // 筛选条件
  }
  
  // 🌍 全局状态 (整个系统的共享数据)  
  globalState: {
    currentUserId: string        // 当前登录用户ID
    authToken: string           // 认证令牌
    selectedDevice: any         // 全局选中设备
    isDarkMode: boolean         // 主题模式
  }
  
  // ⚙️ 环境变量 (系统配置)
  environmentVars: {
    apiBaseUrl: string          // API服务器地址
    apiKey: string              // API密钥
    tenantId: string            // 租户ID
    version: string             // 系统版本
  }
  
  // 🔄 计算值 (动态生成的值)  
  computedValues: {
    currentTimestamp: number     // 当前时间戳
    formatTime: () => string     // 格式化时间
    generateId: () => string     // 生成唯一ID
    deviceStatus: (id: string) => 'online' | 'offline'  // 设备状态判断
  }
}
```

### 🎨 动态参数选择器UI设计

当用户勾选"动态参数"后，value输入框变为参数源选择器：

```vue
<template>
  <!-- 动态参数选择器 -->
  <n-cascader
    v-if="param.isDynamic"
    v-model:value="param.value"
    :options="parameterSourceOptions"
    placeholder="选择参数源"
    check-strategy="child"
    :show-path="false"
    clearable
  />
  
  <!-- 静态值输入框 -->
  <n-input
    v-else
    v-model:value="param.value"
    placeholder="请输入静态值"
  />
</template>
```

**参数源选择器选项结构**：
```typescript
const parameterSourceOptions = [
  {
    label: '组件数据',
    key: 'componentData',
    children: [
      { label: '当前组件ID', key: 'componentData.currentComponentId', value: 'componentData.currentComponentId' },
      { label: '选中设备ID', key: 'componentData.selectedDeviceId', value: 'componentData.selectedDeviceId' },
      { label: '时间范围', key: 'componentData.selectedTimeRange', value: 'componentData.selectedTimeRange' }
    ]
  },
  {
    label: '全局状态',
    key: 'globalState',
    children: [
      { label: '当前用户', key: 'globalState.currentUser.id', value: 'globalState.currentUser.id' },
      { label: '认证令牌', key: 'globalState.authToken', value: 'globalState.authToken' },
      { label: '选中设备', key: 'globalState.selectedDevice.id', value: 'globalState.selectedDevice.id' }
    ]
  },
  {
    label: '环境变量',
    key: 'environmentVars', 
    children: [
      { label: 'API地址', key: 'environmentVars.apiBaseUrl', value: 'environmentVars.apiBaseUrl' },
      { label: 'API密钥', key: 'environmentVars.apiKey', value: 'environmentVars.apiKey' },
      { label: '租户ID', key: 'environmentVars.tenantId', value: 'environmentVars.tenantId' }
    ]
  },
  {
    label: '计算值',
    key: 'computedValues',
    children: [
      { label: '当前时间戳', key: 'computedValues.currentTimestamp', value: 'computedValues.currentTimestamp' },
      { label: '格式化时间', key: 'computedValues.formatTime', value: 'computedValues.formatTime()' },
      { label: '生成ID', key: 'computedValues.generateId', value: 'computedValues.generateId()' }
    ]
  }
]
```

### 🔧 动态参数运行时管理机制

**核心问题**: 动态参数配置好之后，**运行时怎么获取、更新、使用这些参数值？**

```typescript
/**
 * 动态参数运行时管理器
 * 职责：在HTTP请求执行时，实时获取动态参数的实际值
 */
class DynamicParameterManager {
  
  // 第1步：获取参数源数据
  private getDataSources() {
    return {
      // 组件数据：从当前Visual Editor组件获取
      componentData: {
        selectedDeviceId: this.getCurrentComponent().deviceId,
        selectedTimeRange: this.getCurrentComponent().timeRange,
        chartType: this.getCurrentComponent().chartType
      },
      
      // 全局状态：从Pinia Store获取
      globalState: {
        currentUserId: useAuthStore().userInfo?.id,
        authToken: useAuthStore().token,
        selectedDevice: useDeviceStore().currentDevice
      },
      
      // 系统变量：从环境和本地存储获取
      systemVars: {
        apiBaseUrl: import.meta.env.VITE_API_BASE_URL,
        currentTimestamp: Date.now(),
        tenantId: localStorage.getItem('tenantId')
      }
    }
  }
  
  // 第2步：解析参数路径，获取实际值
  resolveParameter(paramPath: string) {
    const dataSources = this.getDataSources()
    
    // 例如: "componentData.selectedDeviceId" 
    // 拆分为: ["componentData", "selectedDeviceId"]
    const [sourceType, ...keyPath] = paramPath.split('.')
    
    // 从数据源中按路径获取值
    let value = dataSources[sourceType]
    for (const key of keyPath) {
      value = value?.[key]
    }
    
    return value
  }
  
  // 第3步：处理HTTP请求参数
  buildHttpParams(config: HttpDataSourceConfig) {
    const result = {
      headers: {},
      requestData: {}  // 统一的请求数据，系统自动决定放URL还是Body
    }
    
    // 处理Headers参数
    config.headers.forEach(header => {
      if (!header.enabled) return
      
      if (header.isDynamic) {
        const value = this.resolveParameter(header.value)
        if (value !== undefined) {
          result.headers[header.key] = value
        }
        // 如果获取不到值，这个header就不发送
      } else {
        result.headers[header.key] = header.value
      }
    })
    
    // 处理请求参数（重点）
    config.requestParams.forEach(param => {
      if (!param.enabled) return
      
      if (param.isDynamic) {
        const value = this.resolveParameter(param.value)
        if (value !== undefined) {
          result.requestData[param.key] = this.convertDataType(value, param.dataType)
        }
        // 如果获取不到值，使用默认值或者不发送
      } else {
        result.requestData[param.key] = this.convertDataType(param.value, param.dataType)
      }
    })
    
    return result
  }
}
```

### 📋 实际使用流程示例

**场景**: 用户在可视化编辑器中添加了一个图表组件，需要获取当前选中设备的温度数据

```typescript
// 1. 用户配置了HTTP数据源
const httpConfig = {
  url: "http://api.example.com/device/data",
  method: "POST",
  requestParams: [
    {
      key: "deviceId",
      value: "componentData.selectedDeviceId",  // 动态参数
      isDynamic: true,
      dataType: "string"
    },
    {
      key: "dataType", 
      value: "temperature",                     // 静态参数
      isDynamic: false,
      dataType: "string"
    },
    {
      key: "timestamp",
      value: "systemVars.currentTimestamp",     // 动态参数
      isDynamic: true,
      dataType: "number"
    }
  ]
}

// 2. 系统执行HTTP请求时的处理过程
class HttpExecutor {
  async executeRequest(config: HttpDataSourceConfig) {
    const paramManager = new DynamicParameterManager()
    
    // 解析所有动态参数
    const resolvedParams = paramManager.buildHttpParams(config)
    
    console.log("解析结果:", resolvedParams.requestData)
    // 输出: {
    //   deviceId: "device_123",        // 从当前组件获取
    //   dataType: "temperature",       // 静态值
    //   timestamp: 1693123456789       // 系统当前时间
    // }
    
    // 根据请求方式智能处理参数
    let requestOptions: RequestInit
    if (config.method === 'GET') {
      // GET请求：参数放URL
      const urlParams = new URLSearchParams(resolvedParams.requestData)
      requestOptions = {
        method: 'GET',
        headers: resolvedParams.headers
      }
      config.url += '?' + urlParams.toString()
    } else {
      // POST/PUT/DELETE：参数放Body
      requestOptions = {
        method: config.method,
        headers: {
          ...resolvedParams.headers,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(resolvedParams.requestData)
      }
    }
    
    // 发送HTTP请求
    const response = await fetch(config.url, requestOptions)
    
    return response.json()
  }
}
```

### ⚡ 参数变化监听和防抖机制

```typescript
class HttpRequestManager {
  private debounceTimers = new Map<string, NodeJS.Timeout>()
  
  // 监听参数变化并防抖执行
  setupParameterWatcher(config: HttpDataSourceConfig, onDataUpdate: (data: any) => void) {
    // 1. 监听组件数据变化
    const component = this.getCurrentComponent()
    watch(() => component.config, () => {
      this.executeWithDebounce(config, onDataUpdate)
    }, { deep: true })
    
    // 2. 监听全局状态变化  
    const authStore = useAuthStore()
    watch(() => authStore.token, () => {
      this.executeWithDebounce(config, onDataUpdate)
    })
  }
  
  // 防抖执行HTTP请求
  private executeWithDebounce(config: HttpDataSourceConfig, callback: (data: any) => void) {
    const requestKey = this.generateRequestKey(config)
    
    // 清除之前的防抖定时器
    if (this.debounceTimers.has(requestKey)) {
      clearTimeout(this.debounceTimers.get(requestKey)!)
    }
    
    const timer = setTimeout(async () => {
      try {
        const paramManager = new DynamicParameterManager()
        const resolvedParams = paramManager.buildHttpParams(config)
        
        // 根据请求方式智能处理参数
        let requestOptions: RequestInit
        if (config.method === 'GET') {
          // GET请求：参数放URL
          const urlParams = new URLSearchParams(resolvedParams.requestData)
          requestOptions = {
            method: 'GET',
            headers: resolvedParams.headers
          }
          config.url += '?' + urlParams.toString()
        } else {
          // POST/PUT/DELETE：参数放Body
          requestOptions = {
            method: config.method,
            headers: {
              ...resolvedParams.headers,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(resolvedParams.requestData)
          }
        }
        
        const response = await fetch(config.url, requestOptions)
        
        const data = await response.json()
        callback(data) // 更新组件数据
      } catch (error) {
        console.error('HTTP请求失败:', error)
      } finally {
        this.debounceTimers.delete(requestKey)
      }
    }, 500) // 500ms防抖
    
    this.debounceTimers.set(requestKey, timer)
  }
}
```

### 🎯 总结：动态参数使用机制

**核心流程**:
1. **配置阶段**: 用户选择参数来源（如"组件数据.设备ID"）
2. **运行阶段**: 系统实时从数据源获取实际值
3. **监听阶段**: 数据源变化时自动触发重新请求
4. **优化阶段**: 防抖避免频繁请求，缓存提升性能

**关键机制**:
- **实时解析**: 每次请求时都重新获取动态参数值
- **智能监听**: 只监听实际使用的数据源变化
- **防抖优化**: 参数快速变化时等待稳定后再发请求
- **缓存策略**: 相同参数的请求结果可以缓存复用

**在Visual Editor的HTTP数据源中使用**:
```typescript
export class HttpDataSource {
  private requestManager = new HttpRequestManager()
  
  async initialize(config: HttpDataSourceConfig) {
    // 1. 设置参数变化监听
    this.requestManager.setupParameterWatcher(config, (data) => {
      this.updateComponentData(data) // 参数变化时重新获取数据
    })
    
    // 2. 初始数据获取
    await this.refreshData()
  }
  
  async refreshData() {
    try {
      // 使用防抖机制执行HTTP请求
      const data = await this.requestManager.executeWithDebounce(this.config, (data) => {
        this.updateComponentData(data)
      })
    } catch (error) {
      console.error('HTTP请求失败:', error)
    }
  }
}
```

---

## 📊 验收标准

### SUBTASK-008完成标准  
- [x] ✅ 现有HttpConfigForm.vue基础组件已分析
- [x] ✅ 完成HTTP配置需求详细调研  
- [x] ✅ 明确HTTP配置功能边界和规格
- [x] ✅ 设计HTTP配置与数据执行器的集成方案
- [x] ✅ 制定HTTP配置开发的分步计划
- [x] ✅ 优化动态参数设计方案(基于用户反馈)
- [x] ✅ 设计完整的动态参数管理系统
- [x] ✅ 确认所有需求细节和技术实现方案

### 📋 核心交付成果
1. **完整的数据结构设计** - 支持Headers和Body参数的动态配置
2. **页签式界面设计方案** - 5个页签的详细交互设计
3. **动态参数管理系统** - DynamicParameterManager完整实现方案
4. **性能优化方案** - 防抖机制和缓存策略
5. **预制模板系统设计** - JSON导入导出功能规划
6. **技术集成方案** - 与现有项目架构的无缝集成

### 📋 后续子任务计划 (基于本设计文档)
1. **SUBTASK-009**: HttpConfigForm页签式界面重构实现
   - 实现5个页签的完整UI界面
   - 集成动态参数选择器 (n-cascader)
   - 实现表单验证和必填字段检查

2. **SUBTASK-010**: 动态参数管理系统开发
   - 实现DynamicParameterManager类
   - 实现HttpRequestDebouncer防抖机制
   - 集成现有Store架构 (auth/device/theme/visual-editor)

3. **SUBTASK-011**: 预制模板系统实现  
   - 实现HttpConfigTemplateManager类
   - 创建预制模板文件和JSON导入功能
   - 提供数据类型和示例给用户

4. **SUBTASK-012**: HTTP执行器增强和集成
   - 扩展UnifiedDataExecutor的HttpExecutor
   - 集成动态参数解析到请求执行流程
   - 实现请求前后脚本处理集成

5. **SUBTASK-013**: RawDataConfigModal集成和测试
   - 将HTTP配置标记为available: true
   - 实现向后兼容的数据结构迁移
   - 完整的系统集成测试和性能验证

---

## 🎯 文档总结

本文档完成了HTTP动态参数配置系统的完整需求分析和技术设计，核心成果包括：

### ✅ 需求确认
- **统一请求参数配置** - 单一requestParams数组，系统智能处理GET→URL参数，POST/PUT/DELETE→Body参数
- **Headers参数独立支持** - 请求头独立配置，主要用于认证和元数据
- **表单严格验证** - 除脚本外所有字段必填，校验通过后自动发送请求
- **防抖性能优化** - 避免参数频繁变化导致的过度请求

### 🏗️ 技术架构
- **四大数据源** - componentData/globalState/systemVars/computedValues
- **运行时管理器** - DynamicParameterManager实时获取和解析动态参数
- **UI组件设计** - 勾选框控制+级联选择器，用户友好的交互体验
- **监听和防抖** - 智能监听数据源变化，防抖优化避免过度请求

### 📋 实施保障
- **基于现有架构** - 复用项目Store系统，无架构冲突
- **完整使用流程** - 从配置到运行的详细示例和集成方案
- **分步实施计划** - 5个子任务的详细开发计划
- **性能和错误处理** - 防抖机制、缓存策略、错误处理等

---

**文档状态**: 最终完整方案，可直接用于开发实施  
**创建时间**: 2025-08-28  
**最后更新**: 2025-08-28 (包含完整动态参数管理系统设计)  
**总页数**: ~50页 (包含详细代码示例和技术方案)