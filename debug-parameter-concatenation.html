<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>调试参数拼接问题</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            background: #f5f5f5;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .result {
            background: #e8f4f8;
            padding: 10px;
            margin: 5px 0;
            border-left: 4px solid #2196F3;
        }
        .error {
            background: #ffebee;
            border-left-color: #f44336;
        }
    </style>
</head>
<body>
    <h1>参数拼接问题调试</h1>
    
    <div class="test-section">
        <h2>问题场景重现</h2>
        <p><strong>问题描述</strong>：默认值"1"和绑定参数路径被错误拼接为"1triple-data-display_xxx"</p>
        
        <h3>测试数据</h3>
        <p><strong>默认值</strong>: "1"</p>
        <p><strong>绑定参数</strong>: "triple-data-display_1756917235813.customize.unit"</p>
        <p><strong>组件实际值</strong>: "" (空字符串)</p>
    </div>

    <div class="test-section">
        <h2>DataItemFetcher.resolveParameterValue() 逻辑测试</h2>
        <div id="dataItemFetcherTest"></div>
    </div>

    <div class="test-section">
        <h2>可能的错误拼接场景测试</h2>
        <div id="concatenationTests"></div>
    </div>

    <script>
        // 模拟 DataItemFetcher.resolveParameterValue() 的逻辑
        function testResolveParameterValue() {
            const testResults = [];

            // 测试参数对象
            const param = {
                key: 'id',
                value: 'triple-data-display_1756917235813.customize.unit',
                selectedTemplate: 'component-property-binding',
                defaultValue: '1',
                dataType: 'string'
            };

            // 模拟组件属性值 (空字符串)
            const mockComponentValue = '';

            testResults.push(`<strong>输入参数:</strong><br>${JSON.stringify(param, null, 2)}`);
            testResults.push(`<strong>模拟组件属性值:</strong> "${mockComponentValue}"`);

            let resolvedValue = param.value;

            // 第一步：检查是否是组件属性绑定
            if (param.selectedTemplate === 'component-property-binding' && typeof param.value === 'string') {
                testResults.push(`<strong>步骤1:</strong> 检测到组件属性绑定: ${param.value}`);
                
                const actualValue = mockComponentValue; // 模拟 getComponentPropertyValue()
                testResults.push(`<strong>步骤2:</strong> 获取组件属性实际值: "${actualValue}"`);
                
                if (actualValue !== undefined && actualValue !== null && actualValue !== '') {
                    resolvedValue = actualValue;
                    testResults.push(`<strong>步骤3a:</strong> 使用绑定值: "${resolvedValue}"`);
                } else {
                    resolvedValue = undefined;
                    testResults.push(`<strong>步骤3b:</strong> 绑定值为空，设置为undefined触发默认值机制`);
                }
            }

            // 第二步：检查是否需要使用默认值
            const isEmpty = resolvedValue === null || 
                          resolvedValue === undefined || 
                          resolvedValue === '' || 
                          (typeof resolvedValue === 'string' && resolvedValue.trim() === '');

            testResults.push(`<strong>步骤4:</strong> isEmpty检查: ${isEmpty}, 当前值: ${resolvedValue}`);

            if (isEmpty) {
                if (param.defaultValue !== undefined && param.defaultValue !== null) {
                    resolvedValue = param.defaultValue;
                    testResults.push(`<strong>步骤5:</strong> 使用默认值: "${resolvedValue}"`);
                } else {
                    testResults.push(`<strong>步骤5:</strong> 无默认值，返回null`);
                    resolvedValue = null;
                }
            }

            testResults.push(`<strong>最终结果:</strong> "${resolvedValue}"`);

            return testResults;
        }

        // 测试可能的错误拼接场景
        function testConcatenationScenarios() {
            const results = [];
            const defaultValue = '1';
            const bindingPath = 'triple-data-display_1756917235813.customize.unit';

            // 场景1: 直接字符串拼接 (错误)
            const wrongConcat1 = defaultValue + bindingPath;
            results.push(`<div class="error"><strong>错误场景1 - 直接拼接:</strong> "${wrongConcat1}"</div>`);

            // 场景2: 模板字符串拼接 (错误)
            const wrongConcat2 = `${defaultValue}${bindingPath}`;
            results.push(`<div class="error"><strong>错误场景2 - 模板拼接:</strong> "${wrongConcat2}"</div>`);

            // 场景3: 条件选择 (正确)
            const componentValue = ''; // 模拟组件值为空
            const correctResult = componentValue || defaultValue;
            results.push(`<div class="result"><strong>正确场景 - 条件选择:</strong> "${correctResult}"</div>`);

            return results;
        }

        // 执行测试并显示结果
        document.addEventListener('DOMContentLoaded', function() {
            // DataItemFetcher 测试
            const fetcherResults = testResolveParameterValue();
            document.getElementById('dataItemFetcherTest').innerHTML = `
                <div class="result">
                    ${fetcherResults.join('<br>')}
                </div>
            `;

            // 拼接场景测试
            const concatResults = testConcatenationScenarios();
            document.getElementById('concatenationTests').innerHTML = concatResults.join('');
        });

        console.log('调试页面加载完成');
    </script>
</body>
</html>